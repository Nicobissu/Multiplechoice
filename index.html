<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Evaluaci√≥n interactiva de termodin√°mica</title>
  <style>
    :root {
      --bg-gradient-start: #f5f7ff;
      --bg-gradient-end: #dfe7fd;
      --card-bg: #ffffff;
      --primary: #6366f1;
      --primary-dark: #4f46e5;
      --text: #1f2937;
      --muted: #6b7280;
      --border: #e2e8f0;
      --success: #22c55e;
      --success-bg: #ecfdf5;
      --error: #ef4444;
      --error-bg: #fee2e2;
      --shadow: 0 20px 45px -35px rgba(79, 70, 229, 0.65);
      --shadow-strong: 0 24px 54px -30px rgba(79, 70, 229, 0.35);
      --radius-lg: 22px;
      --radius-md: 16px;
      --radius-sm: 10px;
    }

    *, *::before, *::after {
      box-sizing: border-box;
    }

    html, body {
      margin: 0;
      padding: 0;
      font-family: "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
      background: linear-gradient(135deg, var(--bg-gradient-start), var(--bg-gradient-end));
      color: var(--text);
      line-height: 1.6;
      min-height: 100%;
    }

    body {
      display: flex;
      justify-content: center;
    }

    main.app {
      width: min(1100px, 95vw);
      padding: 2.5rem 1.25rem 3rem;
    }

    .app-header {
      text-align: center;
      margin-bottom: 2.25rem;
    }

    .app-header h1 {
      margin: 0;
      font-size: clamp(1.8rem, 2.5vw, 2.4rem);
      letter-spacing: -0.02em;
    }

    .app-header p {
      margin: 0.75rem auto 0;
      max-width: 640px;
      color: var(--muted);
      font-size: 1rem;
    }

    .auth-card {
      background: rgba(255, 255, 255, 0.92);
      border-radius: var(--radius-lg);
      padding: 2.25rem 2rem;
      box-shadow: var(--shadow-strong);
      margin-bottom: 2.5rem;
    }

    .auth-card h2 {
      margin: 0;
      font-size: clamp(1.5rem, 2.2vw, 1.85rem);
      letter-spacing: -0.01em;
    }

    .auth-card p {
      margin: 0.75rem 0 0;
      color: var(--muted);
    }

    .auth-form {
      display: grid;
      gap: 1rem;
      margin-top: 1.5rem;
    }

    .form-field {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .form-field label {
      font-weight: 600;
      color: var(--text);
    }

    .form-field input {
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      padding: 0.65rem 0.75rem;
      font-size: 1rem;
      background: #f8fafc;
      transition: border 0.2s ease, box-shadow 0.2s ease;
    }

    .form-field input:focus-visible {
      outline: 3px solid rgba(99, 102, 241, 0.28);
      outline-offset: 2px;
      border-color: var(--primary);
    }

    .auth-submit {
      background: var(--primary);
      color: #ffffff;
      border: none;
      border-radius: 999px;
      padding: 0.75rem 1.5rem;
      font-weight: 600;
      font-size: 1rem;
      cursor: pointer;
      transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
      box-shadow: 0 14px 36px -24px rgba(79, 70, 229, 0.5);
    }

    .auth-submit:hover {
      transform: translateY(-1px);
      background: var(--primary-dark);
    }

    .auth-submit:focus-visible {
      outline: 3px solid rgba(99, 102, 241, 0.3);
      outline-offset: 2px;
    }

    .auth-switch {
      margin: 0;
      font-size: 0.95rem;
      color: var(--muted);
    }

    .link-btn {
      background: none;
      border: none;
      color: var(--primary-dark);
      font-weight: 600;
      cursor: pointer;
      padding: 0;
      text-decoration: underline;
    }

    .link-btn:hover {
      color: var(--primary);
    }

    .link-btn:focus-visible {
      outline: 3px solid rgba(99, 102, 241, 0.28);
      outline-offset: 2px;
    }

    .auth-message {
      margin-top: 1rem;
      font-size: 0.95rem;
      min-height: 1.25rem;
      color: var(--muted);
    }

    .auth-message.is-error {
      color: var(--error);
    }

    .auth-message.is-success {
      color: var(--success);
    }

    .user-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: rgba(255, 255, 255, 0.9);
      border: 1px solid var(--border);
      border-radius: var(--radius-lg);
      padding: 0.85rem 1.2rem;
      margin-bottom: 1.5rem;
      box-shadow: 0 16px 36px -28px rgba(79, 70, 229, 0.2);
    }

    .user-info {
      display: flex;
      align-items: center;
      gap: 0.65rem;
      color: var(--muted);
      font-weight: 600;
    }

    .user-icon {
      font-size: 1.35rem;
    }

    .logout-btn {
      background: transparent;
      border: 1px solid var(--primary);
      color: var(--primary-dark);
      padding: 0.45rem 1rem;
      border-radius: 999px;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.2s ease, color 0.2s ease, transform 0.2s ease, box-shadow 0.2s ease;
    }

    .logout-btn:hover {
      background: var(--primary);
      color: #ffffff;
      transform: translateY(-1px);
      box-shadow: 0 10px 26px -20px rgba(79, 70, 229, 0.6);
    }

    .logout-btn:focus-visible {
      outline: 3px solid rgba(99, 102, 241, 0.28);
      outline-offset: 2px;
    }

    .layout {
      display: flex;
      gap: 1.75rem;
      align-items: flex-start;
    }

    .summary-panel {
      flex: 0 0 240px;
      background: rgba(255, 255, 255, 0.8);
      backdrop-filter: blur(6px);
      border-radius: var(--radius-lg);
      padding: 1.75rem 1.5rem;
      box-shadow: var(--shadow);
      position: sticky;
      top: 1.5rem;
    }

    .summary-panel h2 {
      margin: 0 0 1rem;
      font-size: 1.1rem;
      letter-spacing: 0.02em;
      text-transform: uppercase;
      color: var(--muted);
    }

    .summary-buttons {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(60px, 1fr));
      gap: 0.65rem;
    }

    .summary-btn {
      border: none;
      border-radius: 999px;
      padding: 0.65rem 0;
      background: #eef2ff;
      color: var(--primary-dark);
      font-weight: 600;
      letter-spacing: 0.03em;
      cursor: pointer;
      transition: transform 0.18s ease, box-shadow 0.18s ease, background 0.18s ease;
      box-shadow: 0 12px 24px -18px rgba(79, 70, 229, 0.65);
    }

    .summary-btn:hover {
      transform: translateY(-1px);
    }

    .summary-btn:focus-visible {
      outline: 3px solid rgba(99, 102, 241, 0.35);
      outline-offset: 2px;
    }

    .summary-btn.is-active {
      background: var(--primary);
      color: #ffffff;
      box-shadow: 0 18px 32px -20px rgba(79, 70, 229, 0.7);
      transform: translateY(-1px);
    }

    .summary-btn.is-correct {
      background: rgba(34, 197, 94, 0.15);
      color: #047857;
    }

    .summary-btn.is-incorrect {
      background: rgba(239, 68, 68, 0.15);
      color: #b91c1c;
    }

    .summary-btn.is-active.is-correct,
    .summary-btn.is-active.is-incorrect {
      background: var(--primary);
      color: #ffffff;
    }

    .question-card {
      flex: 1;
      background: rgba(255, 255, 255, 0.95);
      border-radius: var(--radius-lg);
      box-shadow: var(--shadow-strong);
      padding: 2rem 2.25rem;
      display: flex;
      flex-direction: column;
      gap: 1.5rem;
    }

    .question-header {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    .question-meta {
      display: flex;
      align-items: center;
      justify-content: space-between;
      flex-wrap: wrap;
      gap: 0.75rem;
    }

    .chip {
      background: rgba(99, 102, 241, 0.12);
      color: var(--primary-dark);
      border-radius: 999px;
      padding: 0.35rem 0.85rem;
      font-size: 0.85rem;
      font-weight: 600;
      letter-spacing: 0.02em;
    }

    .counter {
      color: var(--muted);
      font-weight: 600;
      font-size: 0.95rem;
    }

    .question-title {
      margin: 0;
      font-size: clamp(1.3rem, 2.2vw, 1.75rem);
      line-height: 1.4;
    }

    .question-helper {
      margin: 0;
      color: var(--muted);
      font-size: 0.95rem;
    }

    .options-wrapper {
      display: flex;
      flex-direction: column;
      gap: 0.9rem;
    }

    .option-card {
      position: relative;
      display: flex;
      align-items: flex-start;
      gap: 1rem;
      padding: 1rem 1.25rem;
      background: var(--card-bg);
      border-radius: var(--radius-md);
      border: 1px solid var(--border);
      box-shadow: 0 14px 36px -28px rgba(15, 23, 42, 0.3);
      cursor: pointer;
      transition: transform 0.2s ease, box-shadow 0.2s ease, border 0.2s ease, background 0.2s ease;
      min-height: 64px;
    }

    .option-card:hover {
      transform: translateY(-2px);
      box-shadow: 0 18px 40px -26px rgba(79, 70, 229, 0.45);
    }

    .option-card:focus-within {
      outline: 3px solid rgba(99, 102, 241, 0.3);
      outline-offset: 2px;
    }

    .option-card.is-locked {
      cursor: default;
      pointer-events: none;
      opacity: 0.92;
    }

    .option-card input {
      position: absolute;
      opacity: 0;
      pointer-events: none;
    }

    .option-indicator {
      width: 22px;
      height: 22px;
      border: 2px solid var(--border);
      border-radius: 50%;
      display: grid;
      place-items: center;
      margin-top: 0.1rem;
      flex-shrink: 0;
      transition: border 0.2s ease, background 0.2s ease;
    }

    .option-card--multi .option-indicator {
      border-radius: 8px;
    }

    .option-indicator::after {
      content: "";
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: var(--primary);
      transform: scale(0);
      transition: transform 0.2s ease, opacity 0.2s ease;
      opacity: 0;
    }

    .option-card--multi .option-indicator::after {
      content: "‚úì";
      width: auto;
      height: auto;
      color: #ffffff;
      font-weight: 700;
      font-size: 0.75rem;
      transform: scale(0);
    }

    .option-card input:checked + .option-indicator {
      border-color: var(--primary);
      background: var(--primary);
    }

    .option-card input:checked + .option-indicator::after {
      transform: scale(1);
      opacity: 1;
    }

    .option-text {
      display: flex;
      flex-direction: column;
      gap: 0.3rem;
      color: var(--text);
    }

    .option-main {
      font-weight: 600;
      font-size: 1rem;
    }

    .option-sub {
      font-size: 0.9rem;
      color: var(--muted);
    }

    .option-card.is-correct {
      border-color: var(--success);
      background: var(--success-bg);
      box-shadow: 0 18px 45px -30px rgba(34, 197, 94, 0.45);
    }

    .option-card.is-incorrect {
      border-color: var(--error);
      background: var(--error-bg);
      box-shadow: 0 18px 45px -30px rgba(239, 68, 68, 0.35);
    }

    .option-card.show-correct:not(.is-correct) {
      border-style: dashed;
      border-color: rgba(34, 197, 94, 0.8);
      background: #f1fdf3;
    }

    .option-card.is-incorrect .option-indicator,
    .option-card.is-incorrect input:checked + .option-indicator {
      border-color: var(--error);
      background: var(--error);
    }

    .option-card.is-correct .option-indicator,
    .option-card.is-correct input:checked + .option-indicator {
      border-color: var(--success);
      background: var(--success);
    }

    .match-row {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem 1rem;
      align-items: center;
      background: var(--card-bg);
      border: 1px solid var(--border);
      border-radius: var(--radius-md);
      padding: 0.9rem 1.15rem;
      box-shadow: 0 14px 36px -28px rgba(15, 23, 42, 0.28);
      transition: border 0.2s ease, background 0.2s ease, box-shadow 0.2s ease;
    }

    .match-row select {
      flex: 1;
      min-width: 220px;
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      padding: 0.55rem 0.65rem;
      font-size: 0.95rem;
      color: var(--text);
      background: #f8fafc;
      transition: border 0.2s ease, box-shadow 0.2s ease;
    }

    .match-row select:focus-visible {
      outline: 3px solid rgba(99, 102, 241, 0.28);
      outline-offset: 2px;
      border-color: var(--primary);
    }

    .match-term {
      font-weight: 600;
      color: var(--text);
      min-width: 130px;
      flex: 1 1 260px;
    }

    .match-answer {
      font-size: 0.85rem;
      color: var(--muted);
      margin-left: auto;
      opacity: 0;
      transform: translateY(-4px);
      transition: opacity 0.2s ease, transform 0.2s ease, color 0.2s ease;
    }

    .match-row.show-answer .match-answer {
      opacity: 1;
      transform: translateY(0);
      color: var(--text);
      font-weight: 600;
    }

    .match-row.is-correct {
      border-color: var(--success);
      background: var(--success-bg);
      box-shadow: 0 18px 45px -32px rgba(34, 197, 94, 0.45);
    }

    .match-row.is-incorrect {
      border-color: var(--error);
      background: var(--error-bg);
      box-shadow: 0 18px 45px -32px rgba(239, 68, 68, 0.35);
    }

    .group-tf-row {
      align-items: flex-start;
    }

    .group-tf-controls {
      display: flex;
      gap: 0.75rem;
      flex-wrap: wrap;
      margin-left: auto;
    }

    .group-tf-option {
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
      font-weight: 600;
      color: var(--text);
      background: #f8fafc;
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      padding: 0.35rem 0.75rem;
      cursor: pointer;
      transition: background 0.2s ease, border 0.2s ease, color 0.2s ease;
    }

    .group-tf-option:hover {
      border-color: var(--primary);
    }

    .group-tf-option input {
      accent-color: var(--primary);
    }

    .group-tf-option.is-active {
      border-color: var(--primary);
      background: rgba(99, 102, 241, 0.15);
      color: var(--primary-dark);
    }

    .group-tf-option.is-correct,
    .group-tf-option.show-correct {
      border-color: var(--success);
      background: var(--success-bg);
      color: #047857;
    }

    .group-tf-option.is-incorrect {
      border-color: var(--error);
      background: var(--error-bg);
      color: #b91c1c;
    }

    .group-tf-row.is-locked .group-tf-option {
      cursor: default;
      opacity: 0.95;
    }

    .feedback-area {
      border-top: 1px solid rgba(148, 163, 184, 0.2);
      padding-top: 1.25rem;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      min-height: 92px;
    }

    .feedback-message {
      margin: 0;
      font-weight: 600;
      color: var(--muted);
    }

    .feedback-message.success {
      color: #047857;
    }

    .feedback-message.error {
      color: #b91c1c;
    }

    .feedback-message.warning {
      color: #b45309;
    }

    .correct-answer,
    .explanation-text {
      margin: 0;
      color: var(--muted);
      font-size: 0.95rem;
    }

    .explanation-text {
      color: #475569;
    }

    .question-footer {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 1rem;
      flex-wrap: wrap;
    }

    .retry-btn {
      background: rgba(99, 102, 241, 0.12);
      color: var(--primary-dark);
      border: none;
      border-radius: 999px;
      padding: 0.6rem 1.2rem;
      font-weight: 600;
      letter-spacing: 0.02em;
      cursor: pointer;
      transition: background 0.2s ease, transform 0.2s ease;
    }

    .retry-btn:hover {
      background: rgba(99, 102, 241, 0.2);
      transform: translateY(-1px);
    }

    .retry-btn:disabled,
    .retry-btn[hidden] {
      display: none;
    }

    .nav-buttons {
      display: flex;
      gap: 0.75rem;
    }

    .nav-btn {
      border: none;
      border-radius: 999px;
      padding: 0.75rem 1.5rem;
      font-weight: 600;
      letter-spacing: 0.03em;
      cursor: pointer;
      background: var(--primary);
      color: #ffffff;
      transition: background 0.2s ease, transform 0.2s ease, box-shadow 0.2s ease;
      box-shadow: 0 18px 40px -28px rgba(79, 70, 229, 0.7);
    }

    .nav-btn:hover {
      background: var(--primary-dark);
      transform: translateY(-1px);
    }

    .nav-btn:disabled {
      background: rgba(99, 102, 241, 0.25);
      cursor: not-allowed;
      box-shadow: none;
    }

    .reset-btn {
      margin-top: 1rem;
      align-self: center;
      border: none;
      border-radius: 999px;
      padding: 0.65rem 1.5rem;
      font-weight: 600;
      letter-spacing: 0.03em;
      cursor: pointer;
      background: rgba(99, 102, 241, 0.18);
      color: var(--primary-dark);
      transition: background 0.2s ease, transform 0.2s ease;
    }

    .reset-btn:hover {
      background: rgba(99, 102, 241, 0.28);
      transform: translateY(-1px);
    }

    button:focus-visible {
      outline: 3px solid rgba(99, 102, 241, 0.4);
      outline-offset: 2px;
    }

    .results-card {
      margin-top: 2.5rem;
      background: rgba(255, 255, 255, 0.92);
      padding: 2rem;
      border-radius: var(--radius-lg);
      box-shadow: var(--shadow);
      text-align: center;
      display: flex;
      flex-direction: column;
      gap: 0.6rem;
    }

    .results-card h2 {
      margin: 0;
      letter-spacing: 0.02em;
    }

    .score-line {
      margin: 0;
      font-size: 1.05rem;
      font-weight: 600;
      color: var(--text);
    }

    .score-percentage {
      margin: 0;
      font-size: 2rem;
      font-weight: 700;
      letter-spacing: -0.02em;
      color: var(--primary-dark);
    }

    .badge {
      display: inline-flex;
      align-self: center;
      align-items: center;
      justify-content: center;
      padding: 0.45rem 1.25rem;
      background: rgba(99, 102, 241, 0.18);
      color: var(--primary-dark);
      border-radius: 999px;
      font-weight: 600;
      letter-spacing: 0.05em;
      text-transform: uppercase;
    }

    .resume-note {
      margin: 0.75rem 0 0;
      color: var(--muted);
      font-size: 0.9rem;
    }

    @media (max-width: 960px) {
      .auth-card {
        padding: 1.9rem 1.75rem;
      }

      .layout {
        flex-direction: column;
      }

      .summary-panel {
        width: 100%;
        position: static;
        order: 2;
      }

      .question-card {
        order: 1;
        padding: 1.75rem 1.5rem;
      }

      .match-row {
        flex-direction: column;
        align-items: flex-start;
      }

      .match-row select {
        width: 100%;
      }

      .match-answer {
        margin-left: 0;
      }
    }

    @media (max-width: 600px) {
      main.app {
        width: 100%;
        padding: 1.75rem 1rem 2.5rem;
      }

      .auth-card {
        padding: 1.5rem 1.25rem;
      }

      .user-bar {
        flex-direction: column;
        align-items: flex-start;
        gap: 0.75rem;
      }

      .summary-buttons {
        grid-template-columns: repeat(auto-fit, minmax(56px, 1fr));
      }

      .question-card {
        padding: 1.5rem 1.2rem;
      }

      .nav-buttons {
        width: 100%;
        justify-content: space-between;
      }

      .nav-btn {
        flex: 1;
      }

      .group-tf-controls {
        width: 100%;
        margin-left: 0;
        justify-content: flex-start;
      }
    }
  </style>
</head>
<body>
  <main class="app">
    <section class="auth-card" id="authSection">
      <h2 id="authTitle">Ingres√° a tu cuenta</h2>
      <p id="authSubtitle">Registrate o inici√° sesi√≥n para guardar tu progreso y tus resultados.</p>
      <form id="loginForm" class="auth-form" autocomplete="on">
        <div class="form-field">
          <label for="loginUsername">Usuario</label>
          <input type="text" id="loginUsername" name="username" autocomplete="username" required />
        </div>
        <div class="form-field">
          <label for="loginPassword">Contrase√±a</label>
          <input type="password" id="loginPassword" name="password" autocomplete="current-password" required />
        </div>
        <button type="submit" class="auth-submit">Iniciar sesi√≥n</button>
        <p class="auth-switch">
          ¬øNo ten√©s una cuenta?
          <button type="button" class="link-btn" id="showRegisterBtn">Registrate</button>
        </p>
      </form>
      <form id="registerForm" class="auth-form" autocomplete="off" hidden>
        <div class="form-field">
          <label for="registerUsername">Eleg√≠ un usuario</label>
          <input type="text" id="registerUsername" name="username" autocomplete="username" required />
        </div>
        <div class="form-field">
          <label for="registerPassword">Contrase√±a</label>
          <input type="password" id="registerPassword" name="password" autocomplete="new-password" required />
        </div>
        <div class="form-field">
          <label for="registerConfirm">Repet√≠ la contrase√±a</label>
          <input type="password" id="registerConfirm" name="confirmPassword" autocomplete="new-password" required />
        </div>
        <button type="submit" class="auth-submit">Crear cuenta</button>
        <p class="auth-switch">
          ¬øYa ten√©s usuario?
          <button type="button" class="link-btn" id="showLoginBtn">Iniciar sesi√≥n</button>
        </p>
      </form>
      <p class="auth-message" id="authMessage" role="alert"></p>
    </section>
    <div id="quizSection" hidden>
      <div class="user-bar" id="userBar" hidden>
        <div class="user-info">
          <span class="user-icon" aria-hidden="true">üë§</span>
          <span>Sesi√≥n iniciada como <strong id="currentUserLabel"></strong></span>
        </div>
        <button type="button" class="logout-btn" id="logoutBtn">Cerrar sesi√≥n</button>
      </div>
      <header class="app-header">
        <h1>Evaluaci√≥n interactiva de termodin√°mica y dise√±o de ingenier√≠a</h1>
        <p>Respond√© las preguntas y obten√© retroalimentaci√≥n inmediata. Inici√° sesi√≥n con tu usuario para que tu progreso se guarde de manera personal en este dispositivo.</p>
      </header>
      <div class="layout">
        <aside class="summary-panel" aria-label="Resumen de preguntas">
          <h2>Resumen</h2>
          <div class="summary-buttons" id="summaryButtons"></div>
        </aside>
        <section class="question-card" id="questionCard" aria-live="polite">
          <div id="questionContent"></div>
          <div class="question-footer">
            <button type="button" class="retry-btn" id="retryButton" hidden>Reintentar</button>
            <div class="nav-buttons">
              <button type="button" class="nav-btn" id="prevBtn">Anterior</button>
              <button type="button" class="nav-btn" id="nextBtn">Siguiente</button>
            </div>
          </div>
        </section>
      </div>
      <section class="results-card" id="resultsCard" aria-live="polite">
        <h2>Resultados</h2>
        <p class="score-line"><span id="scoreCount">0 / 0</span> respuestas correctas</p>
        <p class="score-percentage" id="scorePercentage">0%</p>
        <span class="badge" id="scoreBadge">A seguir</span>
        <p class="resume-note">Tus respuestas quedan guardadas localmente junto a tu usuario para que puedas continuar m√°s tarde.</p>
        <button type="button" class="reset-btn" id="resetBtn">Reiniciar evaluaci√≥n</button>
      </section>
    </div>
  </main>
  <script>
    const QUESTIONS = [
      {
        id: 1,
        type: 'multi',
        prompt: 'Seleccionar cu√°les son los modos de transferencia de energ√≠a en termodin√°mica:',
        options: ['Energ√≠a Potencial', 'Trabajo', 'Energ√≠a Cin√©tica', 'Energ√≠a Interna', 'Entrop√≠a', 'Calor'],
        correct: [1, 5],
        explanation: 'En termodin√°mica, la energ√≠a se transfiere como trabajo o como calor; las dem√°s son formas almacenadas o propiedades.'
      },
      {
        id: 2,
        type: 'multi',
        prompt: 'Seleccionar cu√°les son los modos de transferencia de calor:',
        options: ['Radiaci√≥n', 'Convecci√≥n', 'Evaporaci√≥n', 'Fusi√≥n', 'Conducci√≥n'],
        correct: [0, 1, 4],
        explanation: 'Los mecanismos fundamentales de transferencia de calor son conducci√≥n, convecci√≥n y radiaci√≥n.'
      },
      {
        id: 3,
        type: 'tf',
        prompt: 'Seg√∫n el convenio de signos, Q > 0 cuando el calor entra al sistema.',
        correct: true,
        explanation: 'Por convenio cl√°sico, Q>0 hacia el sistema y Q<0 desde el sistema.'
      },
      {
        id: 4,
        type: 'multi',
        prompt: 'Ciclos utilizados solo en motores de combusti√≥n externa:',
        options: ['Ciclo Di√©sel', 'Ciclo Rankine', 'Ciclo Brayton', 'Ciclo Otto'],
        correct: [1],
        explanation: 'El ciclo Rankine (m√°quinas de vapor) es de combusti√≥n externa en su configuraci√≥n t√≠pica.'
      },
      {
        id: 5,
        type: 'match',
        prompt: 'Emparejar cada principio con su definici√≥n:',
        left: [
          'Transferir calor de un cuerpo fr√≠o a uno caliente como √∫nico efecto es imposible.',
          'No existe ciclo que convierta √≠ntegramente el calor absorbido en trabajo.',
          'Relaci√≥n entre calor, trabajo y energ√≠a interna en un sistema.'
        ],
        right: [
          'Formulaci√≥n de Clausius',
          'Enunciado de Kelvin‚ÄìPlanck',
          'Principio de conservaci√≥n de la energ√≠a'
        ],
        correct: [0, 1, 2],
        explanation: 'Clausius proh√≠be transferencia espont√°nea de fr√≠o a caliente; Kelvin‚ÄìPlanck proh√≠be la conversi√≥n total de Q en W; el primero es la 1¬™ Ley.'
      },
      {
        id: 6,
        type: 'multi',
        prompt: 'Componentes principales de un motor de turbina de gas de ciclo abierto:',
        options: ['C√°mara de combusti√≥n', 'Filtro', 'Turbina', 'Compresor', 'Trampa de agua', 'Bomba'],
        correct: [0, 2, 3],
        explanation: 'Las tres etapas b√°sicas: compresor, combustor, turbina.'
      },
      {
        id: 7,
        type: 'single',
        prompt: '¬øCu√°l curva corresponde a un ciclo de Carnot?',
        options: ['Dos isotermas y dos isobaras', 'Dos isobaras y dos adiab√°ticas', 'Dos isotermas y dos isocoras', 'Dos isotermas y dos adiab√°ticas'],
        correct: 3,
        explanation: 'Carnot se compone de dos procesos isotermos y dos adiab√°ticos reversibles.'
      },
      {
        id: 8,
        type: 'multi',
        prompt: 'Seleccione cu√°les son etapas de dise√±o en ingenier√≠a:',
        options: [
          'Identificar alternativas realizables',
          'Determinar restricciones y criterios',
          'Elegir la soluci√≥n solo por menor costo',
          'Definir objetivos del dise√±o',
          'Concretar especificaciones cualitativas'
        ],
        correct: [0, 1, 3, 4],
        explanation: 'Elegir solo por costo ignora criterios esenciales del dise√±o.'
      },
      {
        id: 9,
        type: 'tf',
        prompt: 'El rendimiento de un ciclo Ericsson ideal es el mismo que el de Carnot.',
        correct: true,
        explanation: 'Con regeneraci√≥n ideal e isotermas, Ericsson alcanza la eficiencia de Carnot.'
      },
      {
        id: 10,
        type: 'match',
        prompt: 'Metodolog√≠a: emparejar cada paso con su definici√≥n.',
        left: [
          'Establecer con tus palabras lo que debe calcularse.',
          'Listar consideraciones e idealizaciones.',
          'Establecer brevemente lo que es conocido.',
          'Dibujar el esquema y rotular datos.',
          'Expresar ecuaciones y relaciones y resolver.'
        ],
        right: [
          'Determinar lo que se debe hallar',
          'Establecer consideraciones e hip√≥tesis',
          'Determinar lo conocido',
          'Determinar los datos y diagramas',
          'Realizar el an√°lisis'
        ],
        correct: [0, 1, 2, 3, 4],
        explanation: 'Corresponde al flujo cl√°sico de resoluci√≥n de problemas en ingenier√≠a.'
      },
      {
        id: 11,
        type: 'match',
        prompt: 'Ordenar los pasos (1‚Üí5).',
        left: [
          'Paso 5. Realizar el an√°lisis.',
          'Paso 4. Establecer consideraciones e hip√≥tesis.',
          'Paso 3. Determinar los diagramas y datos.',
          'Paso 2. Determinar lo que se debe hallar.',
          'Paso 1. Determinar lo conocido.'
        ],
        right: ['1', '2', '3', '4', '5'],
        correct: [4, 3, 2, 1, 0],
        explanation: 'Secuencia l√≥gica del m√©todo propuesto.'
      },
      {
        id: 12,
        type: 'multi',
        prompt: 'Ejemplos de restricci√≥n en dise√±o y an√°lisis:',
        options: ['Est√°ndares de seguridad', 'Est√©tica final', 'Est√°ndares ambientales', 'Costos'],
        correct: [0, 2, 3],
        explanation: 'Seguridad, ambiente y costos suelen figurar como restricciones; la est√©tica es criterio pero no siempre una restricci√≥n dura.'
      },
      {
        id: 13,
        type: 'tf',
        prompt: 'Un flujo unidimensional es un flujo de materia que entra o sale de un volumen de control.',
        correct: false,
        explanation: '1D describe variaci√≥n principal en una sola direcci√≥n; lo otro describe un sistema abierto.'
      },
      {
        id: 14,
        type: 'single',
        prompt: '¬øEn qu√© componente la velocidad del fluido disminuye en la direcci√≥n del flujo?',
        options: ['Difusor', 'Compresor', 'Intercambiador de calor', 'Bomba', 'Tobera'],
        correct: 0,
        explanation: 'El difusor ensancha el √°rea y reduce la velocidad aumentando la presi√≥n.'
      },
      {
        id: 15,
        type: 'tf',
        prompt: 'Una turbom√°quina donde "se produce calor" al pasar un fluido por √°labes solidarios a un eje.',
        correct: false,
        explanation: 'La funci√≥n principal es intercambio de trabajo, no producir calor como √∫nico efecto.'
      },
      {
        id: 16,
        type: 'tf',
        prompt: 'Las variaciones de energ√≠a cin√©tica y potencial suelen ser muy peque√±as y pueden despreciarse.',
        correct: true,
        explanation: 'Es una aproximaci√≥n com√∫n en balances de energ√≠a de equipos.'
      },
      {
        id: 17,
        type: 'multi',
        prompt: 'Ejemplos de compresores alternativos:',
        options: ['Centr√≠fugos', 'Tipo Roots', 'De biela y pist√≥n', 'De diafragma', 'De flujo axial'],
        correct: [2, 3],
        explanation: 'Biela-pist√≥n y diafragma son alternativos; centr√≠fugos/axiales son turbocompresores; Roots es de l√≥bulos rotativos.'
      },
      {
        id: 18,
        type: 'multi',
        prompt: 'En qu√© componentes se realiza trabajo para modificar el estado del fluido:',
        options: ['Bombas', 'Compresores', 'Difusores', 'Toberas', 'Turbinas'],
        correct: [0, 1],
        explanation: 'Bombas/compresores consumen trabajo; la turbina entrega trabajo al eje.'
      },
      {
        id: 19,
        type: 'tf',
        prompt: 'Los compresores aumentan la presi√≥n por transferencia de energ√≠a en forma de calor.',
        correct: false,
        explanation: 'El aumento de presi√≥n se logra por trabajo mec√°nico sobre el fluido.'
      },
      {
        id: 20,
        type: 'multi',
        prompt: 'Aplicaciones de intercambiadores de calor:',
        options: [
          'C√°mara de combusti√≥n',
          'Condensador de heladera',
          'Bomba de central t√©rmica',
          'Compresor de heladera',
          'Radiador de autom√≥vil',
          'Evaporador de un generador de vapor',
          'Turbina de vapor'
        ],
        correct: [1, 4, 5],
        explanation: 'Condensadores, radiadores y generadores de vapor intercambian calor entre corrientes.'
      },
      {
        id: 21,
        type: 'match',
        prompt: 'Unir cada modo con su descripci√≥n.',
        left: [
          'Calor entre cuerpos en contacto a distinta T.',
          'Calor mediado por un fluido por efecto de campo de T y velocidades.',
          'Calor por emisi√≥n/absorci√≥n de radiaci√≥n electromagn√©tica.'
        ],
        right: ['Conducci√≥n', 'Convecci√≥n', 'Radiaci√≥n'],
        correct: [0, 1, 2],
        explanation: 'Definiciones est√°ndar de conducci√≥n, convecci√≥n y radiaci√≥n.'
      },
      {
        id: 22,
        type: 'multi',
        prompt: 'Verdadero o falso (marca V para verdadero y F para falso).',
        subitems: [
          'Si un fluido es incompresible, cv = cp.',
          'El calor espec√≠fico es una propiedad extensiva.',
          'Calor espec√≠fico: calor para elevar en m√°s de una unidad de temperatura a 1 kg.'
        ],
        correct: [true, false, false],
        explanation: 'Para incompresible ideal cp‚âàcv; el calor espec√≠fico es intensivo; la definici√≥n correcta refiere a "una unidad" de temperatura.'
      },
      {
        id: 23,
        type: 'single',
        prompt: 'En un intercambiador de placas, ¬øc√≥mo se intercambia energ√≠a entre fluidos?',
        options: ['Conducci√≥n y convecci√≥n', 'Conducci√≥n y radiaci√≥n', 'Convecci√≥n y radiaci√≥n', 'Solo convecci√≥n', 'Conducci√≥n, convecci√≥n y radiaci√≥n', 'Solo radiaci√≥n', 'Solo conducci√≥n'],
        correct: 0,
        explanation: 'Convecci√≥n en cada lado y conducci√≥n a trav√©s de la placa.'
      },
      {
        id: 24,
        type: 'tf',
        prompt: 'En un intercambiador, solo puede desperdiciarse la variaci√≥n de energ√≠a potencial.',
        correct: false,
        explanation: 'Tambi√©n hay p√©rdidas por fricci√≥n, t√©rmicas, etc.'
      },
      // 25‚Äì44: repetidos/variantes del mismo banco (con las mismas respuestas):
      {
        id: 25,
        type: 'multi',
        prompt: 'Seleccionar cu√°les son los modos de transferencia de energ√≠a en termodin√°mica:',
        options: ['Energ√≠a cin√©tica', 'Trabajo', 'Energ√≠a interna', 'Entrop√≠a', 'Calor', 'Energ√≠a potencial'],
        correct: [1, 4],
        explanation: 'Solo trabajo y calor son modos de transferencia.'
      },
      {
        id: 26,
        type: 'multi',
        prompt: 'Seleccionar cu√°les son los modos de transferencia de calor:',
        options: ['Convecci√≥n', 'Radiaci√≥n', 'Evaporaci√≥n', 'Fusi√≥n', 'Conducci√≥n'],
        correct: [0, 1, 4],
        explanation: 'Conducci√≥n, convecci√≥n y radiaci√≥n.'
      },
      {
        id: 27,
        type: 'tf',
        prompt: 'Seg√∫n el convenio de signos, Q > 0 hacia el sistema y Q < 0 desde el sistema.',
        correct: true,
        explanation: 'Convenci√≥n cl√°sica.'
      },
      {
        id: 28,
        type: 'single',
        prompt: 'Ciclos utilizados solo en motores de combusti√≥n externa:',
        options: ['Ciclo Di√©sel', 'Ciclo Otto', 'Ciclo Rankine', 'Ciclo Brayton'],
        correct: 2,
        explanation: 'Rankine t√≠pico = combusti√≥n externa.'
      },
      {
        id: 29,
        type: 'match',
        prompt: 'Emparejar principios y enunciados:',
        left: [
          'Intercambia trabajo y calor; acumula energ√≠a interna.',
          'Imposible transferir calor de fr√≠o a caliente como √∫nico efecto.',
          'Imposible convertir √≠ntegramente el calor absorbido en trabajo en un ciclo.'
        ],
        right: [
          'Principio de conservaci√≥n de la energ√≠a',
          'Formulaci√≥n de Clausius',
          'Enunciado de Kelvin‚ÄìPlanck'
        ],
        correct: [0, 1, 2],
        explanation: '1¬™ Ley y dos enunciados de la 2¬™ Ley.'
      },
      {
        id: 30,
        type: 'multi',
        prompt: '¬øCu√°les corresponden al 2¬∫ principio de la termodin√°mica?',
        options: [
          'Q fluye de T alta a T baja.',
          'Imposible transferir calor de fr√≠o a caliente como √∫nico efecto.',
          'Conservaci√≥n de la energ√≠a en sistemas.',
          'Imposible convertir √≠ntegramente el calor en trabajo en un ciclo.',
          'Un sistema puede intercambiar W y Q.'
        ],
        correct: [0, 1, 3],
        explanation: 'Direccionalidad del calor (a), Clausius (b) y Kelvin‚ÄìPlanck (d).'
      },
      {
        id: 31,
        type: 'tf',
        prompt: 'El enunciado de Kelvin‚ÄìPlanck es: "...transferir calor de un cuerpo fr√≠o a otro m√°s caliente como √∫nico efecto".',
        correct: false,
        explanation: 'Ese enunciado corresponde a Clausius; Kelvin‚ÄìPlanck trata sobre convertir totalmente calor en trabajo.'
      },
      {
        id: 32,
        type: 'single',
        prompt: 'Clasificaci√≥n de un motor de explosi√≥n de autom√≥viles:',
        options: ['Combusti√≥n externa alternativa', 'Combusti√≥n externa rotativa', 'Combusti√≥n interna alternativa', 'Combusti√≥n interna rotativa'],
        correct: 2,
        explanation: 'Motor de encendido por chispa: combusti√≥n interna alternativa.'
      },
      {
        id: 33,
        type: 'match',
        prompt: 'Emparejar aplicaci√≥n con clasificaci√≥n (considerando configuraciones t√≠picas):',
        left: [
          'Turbina de gas ciclo abierto',
          'Turbina de gas ciclo cerrado',
          'Motor de explosi√≥n',
          'M√°quina de vapor (turbina)'
        ],
        right: [
          'Combusti√≥n interna rotativa',
          'Combusti√≥n externa rotativa',
          'Combusti√≥n interna alternativa',
          'Combusti√≥n externa alternativa'
        ],
        correct: [0, 1, 2, 1],
        explanation: 'Abierto: interna rotativa. Cerrado: calentamiento externo. Motor de explosi√≥n: interna alternativa. La m√°quina de vapor con turbina es externa rotativa.'
      },
      {
        id: 34,
        type: 'multi',
        prompt: 'Aplicaciones del ciclo Brayton:',
        options: ['Motor de combusti√≥n interna', 'M√°quina de vapor', 'Turbina de avi√≥n', 'Turbina de vapor', 'Turbina de gas'],
        correct: [2, 4],
        explanation: 'Brayton rige turbinas de gas y turborreactores.'
      },
      {
        id: 35,
        type: 'single',
        prompt: '¬øQu√© ciclo puede lograr la m√°xima eficiencia reversible?',
        options: ['Otto', 'Di√©sel', 'Rankine', 'Brayton', 'Carnot'],
        correct: 4,
        explanation: 'Carnot fija el l√≠mite superior reversible.'
      },
      {
        id: 36,
        type: 'tf',
        prompt: 'Existen rendimientos m√°s altos que el ciclo de Carnot.',
        correct: false,
        explanation: 'Ninguna m√°quina t√©rmica reversible supera a Carnot entre las mismas T.'
      },
      {
        id: 37,
        type: 'single',
        prompt: 'Un ciclo de Carnot est√° compuesto por:',
        options: [
          'Dos procesos isotermos y dos adiab√°ticos',
          'Dos isoc√≥ricos y dos adiab√°ticos',
          'Dos isotermos y dos isob√°ricos',
          'Dos isoc√≥ricos y dos isotermos',
          'Dos isob√°ricos y dos adiab√°ticos'
        ],
        correct: 0,
        explanation: 'Isotermos + adiab√°ticos.'
      },
      {
        id: 38,
        type: 'tf',
        prompt: 'Un ciclo Ericsson reversible est√° formado por dos isocoras y dos isobaras.',
        correct: false,
        explanation: 'Ericsson ideal: compresi√≥n/expansi√≥n isot√©rmica y calentamiento/enfriamiento isob√°rico con regeneraci√≥n.'
      },
      {
        id: 39,
        type: 'multi',
        prompt: 'Restricciones en dise√±o y an√°lisis de ingenier√≠a:',
        options: ['Costos', 'Est√©tica final', 'Est√°ndares de medio ambiente', 'Est√°ndares de seguridad'],
        correct: [0, 2, 3],
        explanation: 'Costos, ambiente y seguridad suelen ser restricciones clave.'
      },
      {
        id: 40,
        type: 'tf',
        prompt: 'Un flujo unidimensional es un flujo de materia que entra o sale de un volumen de control.',
        correct: false,
        explanation: 'Eso describe un sistema abierto; 1D refiere a c√≥mo var√≠an las propiedades.'
      },
      {
        id: 41,
        type: 'single',
        prompt: '¬øEn qu√© componente disminuye la velocidad en la direcci√≥n del flujo?',
        options: ['Difusor', 'Bomba', 'Compresor', 'Tobera', 'Intercambiador de calor'],
        correct: 0,
        explanation: 'El difusor reduce velocidad y eleva presi√≥n.'
      },
      {
        id: 42,
        type: 'tf',
        prompt: 'Dispositivo donde "se produce calor" por el paso de un fluido por √°labes solidarios a un eje.',
        correct: false,
        explanation: 'Las turbom√°quinas intercambian trabajo principalmente.'
      },
      {
        id: 43,
        type: 'single',
        prompt: 'Intercambio de energ√≠a en un intercambiador de placas:',
        options: ['Solo Convecci√≥n', 'Conducci√≥n, convecci√≥n y radiaci√≥n', 'Conducci√≥n y radiaci√≥n', 'Convecci√≥n y radiaci√≥n', 'Solo conducci√≥n', 'Solo radiaci√≥n', 'Conducci√≥n y convecci√≥n'],
        correct: 6,
        explanation: 'Conducci√≥n a trav√©s de la placa y convecci√≥n en los canales.'
      },
      {
        id: 44,
        type: 'tf',
        prompt: 'En un intercambiador, solo se puede desperdiciar la variaci√≥n de energ√≠a potencial.',
        correct: false,
        explanation: 'Hay m√∫ltiples p√©rdidas mec√°nicas y t√©rmicas adem√°s de la potencial.'
      }
    ];

    const questions = normalizeQuestions(QUESTIONS);

    const typeLabels = {
      single: 'Selecci√≥n √∫nica',
      multi: 'Selecci√≥n m√∫ltiple',
      tf: 'Verdadero / Falso',
      match: 'Emparejar',
      group_tf: 'Verdadero / Falso (m√∫ltiple)'
    };

    const USER_STORAGE_KEY = 'thermoQuizUsers_v1';
    const LEGACY_STORAGE_KEY = 'thermoEngineeringQuiz_v1';
    let currentUser = null;
    let state = createDefaultState();

    const authSection = document.getElementById('authSection');
    const authTitle = document.getElementById('authTitle');
    const authSubtitle = document.getElementById('authSubtitle');
    const loginForm = document.getElementById('loginForm');
    const registerForm = document.getElementById('registerForm');
    const authMessage = document.getElementById('authMessage');
    const showRegisterBtn = document.getElementById('showRegisterBtn');
    const showLoginBtn = document.getElementById('showLoginBtn');
    const quizSection = document.getElementById('quizSection');
    const userBar = document.getElementById('userBar');
    const currentUserLabel = document.getElementById('currentUserLabel');
    const logoutBtn = document.getElementById('logoutBtn');

    const summaryContainer = document.getElementById('summaryButtons');
    const questionContent = document.getElementById('questionContent');
    const retryButton = document.getElementById('retryButton');
    const prevBtn = document.getElementById('prevBtn');
    const nextBtn = document.getElementById('nextBtn');
    const resetBtn = document.getElementById('resetBtn');
    const scoreCountEl = document.getElementById('scoreCount');
    const scorePercentageEl = document.getElementById('scorePercentage');
    const scoreBadgeEl = document.getElementById('scoreBadge');

    if (showRegisterBtn) {
      showRegisterBtn.addEventListener('click', () => {
        toggleAuthMode('register');
      });
    }

    if (showLoginBtn) {
      showLoginBtn.addEventListener('click', () => {
        toggleAuthMode('login');
      });
    }

    if (loginForm) {
      loginForm.addEventListener('submit', async event => {
        event.preventDefault();
        await handleLogin();
      });
    }

    if (registerForm) {
      registerForm.addEventListener('submit', async event => {
        event.preventDefault();
        await handleRegister();
      });
    }

    if (logoutBtn) {
      logoutBtn.addEventListener('click', () => {
        handleLogout();
      });
    }

    prevBtn.addEventListener('click', () => {
      if (!currentUser) return;
      goToQuestion(state.currentIndex - 1);
    });

    nextBtn.addEventListener('click', () => {
      if (!currentUser) {
        toggleAuthMode('login');
        showQuizSection(false);
        showAuthSection(true);
        showAuthMessage('Inici√° sesi√≥n o registrate para continuar con la evaluaci√≥n.', 'error');
        return;
      }
      const question = questions[state.currentIndex];
      if (!question) {
        return;
      }

      const mode = nextBtn.dataset.mode ?? 'check';

      if (mode === 'check') {
        const answer = collectCurrentAnswer(question, true);
        if (answer === null) {
          showIncompleteAnswerMessage();
          return;
        }
        applyEvaluation(question, answer);
        return;
      }

      if (mode === 'results') {
        document.getElementById('resultsCard').scrollIntoView({ behavior: 'smooth', block: 'center' });
        return;
      }

      goToQuestion(state.currentIndex + 1);
    });

    retryButton.addEventListener('click', () => {
      if (!currentUser) return;
      const question = questions[state.currentIndex];
      delete state.answers[question.id];
      delete state.evaluations[question.id];
      saveState();
      renderQuestion();
      renderSummary();
      updateResults();
    });

    if (resetBtn) {
      resetBtn.addEventListener('click', () => {
        if (!currentUser) {
          toggleAuthMode('login');
          showAuthSection(true);
          showQuizSection(false);
          showAuthMessage('Inici√° sesi√≥n para reiniciar la evaluaci√≥n.', 'error');
          return;
        }
        resetQuiz();
      });
    }

    initializeAuth();

    function initializeAuth() {
      toggleAuthMode('login');
      if (loginForm) {
        loginForm.reset();
      }
      if (registerForm) {
        registerForm.reset();
      }
      const database = loadUserDatabase();
      const storedUser = database.currentUser;
      if (storedUser && database.users?.[storedUser]) {
        enterQuiz(storedUser, database);
        return;
      }

      currentUser = null;
      state = createDefaultState();
      showAuthSection(true);
      showQuizSection(false);
      updateUserBar();
      clearQuizUI();
    }

    async function handleLogin() {
      if (!loginForm) return;
      const usernameInput = loginForm.querySelector('input[name="username"]');
      const passwordInput = loginForm.querySelector('input[name="password"]');
      const username = usernameInput?.value?.trim() ?? '';
      const password = passwordInput?.value ?? '';

      if (!username || !password) {
        showAuthMessage('Complet√° usuario y contrase√±a para iniciar sesi√≥n.', 'error');
        return;
      }

      const database = loadUserDatabase();
      const userRecord = database.users?.[username];
      if (!userRecord) {
        showAuthMessage('No encontramos una cuenta con ese usuario.', 'error');
        return;
      }

      const passwordHash = await hashPassword(password);
      if (userRecord.passwordHash !== passwordHash) {
        showAuthMessage('La contrase√±a no coincide.', 'error');
        return;
      }

      database.currentUser = username;
      saveUserDatabase(database);
      loginForm.reset();
      if (registerForm) {
        registerForm.reset();
      }
      enterQuiz(username, database);
    }

    async function handleRegister() {
      if (!registerForm) return;
      const usernameInput = registerForm.querySelector('input[name="username"]');
      const passwordInput = registerForm.querySelector('input[name="password"]');
      const confirmInput = registerForm.querySelector('input[name="confirmPassword"]');
      const username = usernameInput?.value?.trim() ?? '';
      const password = passwordInput?.value ?? '';
      const confirmation = confirmInput?.value ?? '';

      if (username.length < 3) {
        showAuthMessage('El usuario debe tener al menos 3 caracteres.', 'error');
        return;
      }

      if (password.length < 4) {
        showAuthMessage('La contrase√±a debe tener al menos 4 caracteres.', 'error');
        return;
      }

      if (password !== confirmation) {
        showAuthMessage('Las contrase√±as no coinciden.', 'error');
        return;
      }

      const database = loadUserDatabase();
      if (database.users?.[username]) {
        showAuthMessage('Ese usuario ya est√° registrado.', 'error');
        return;
      }

      const passwordHash = await hashPassword(password);
      const initialState = getInitialStateForNewUser(database);

      database.users = database.users ?? {};
      database.users[username] = {
        passwordHash,
        state: initialState
      };
      database.currentUser = username;
      saveUserDatabase(database);

      registerForm.reset();
      if (loginForm) {
        loginForm.reset();
      }
      enterQuiz(username, database);
    }

    function handleLogout() {
      if (currentUser) {
        saveState();
      }
      const database = loadUserDatabase();
      if (currentUser && database.users?.[currentUser]) {
        database.users[currentUser] = {
          ...database.users[currentUser],
          state: createStateSnapshot(state)
        };
      }
      database.currentUser = null;
      saveUserDatabase(database);

      currentUser = null;
      state = createDefaultState();
      showQuizSection(false);
      showAuthSection(true);
      updateUserBar();
      toggleAuthMode('login');
      if (loginForm) {
        loginForm.reset();
      }
      if (registerForm) {
        registerForm.reset();
      }
      clearQuizUI();
      showAuthMessage('Sesi√≥n cerrada. Inici√° sesi√≥n cuando quieras para continuar.', 'success');
    }

    function enterQuiz(username, database = null) {
      currentUser = username;
      state = loadState(username, database);
      showAuthSection(false);
      showQuizSection(true);
      updateUserBar();
      showAuthMessage('');
      init();
    }

    function toggleAuthMode(mode) {
      const isRegister = mode === 'register';
      if (loginForm) {
        loginForm.hidden = isRegister;
      }
      if (registerForm) {
        registerForm.hidden = !isRegister;
      }
      if (authTitle) {
        authTitle.textContent = isRegister ? 'Cre√° tu cuenta' : 'Ingres√° a tu cuenta';
      }
      if (authSubtitle) {
        authSubtitle.textContent = isRegister
          ? 'Ingres√° un usuario y contrase√±a para guardar tus respuestas en este dispositivo.'
          : 'Inici√° sesi√≥n para continuar con tu progreso guardado o crear una cuenta nueva.';
      }
      showAuthMessage('');
    }

    function showAuthSection(show) {
      if (authSection) {
        authSection.hidden = !show;
      }
    }

    function showQuizSection(show) {
      if (quizSection) {
        quizSection.hidden = !show;
      }
    }

    function showAuthMessage(message, type = 'info') {
      if (!authMessage) return;
      authMessage.textContent = message;
      authMessage.classList.remove('is-error', 'is-success');
      if (type === 'error') {
        authMessage.classList.add('is-error');
      } else if (type === 'success') {
        authMessage.classList.add('is-success');
      }
    }

    function updateUserBar() {
      if (!userBar) return;
      if (!currentUser) {
        userBar.hidden = true;
        if (currentUserLabel) {
          currentUserLabel.textContent = '';
        }
        return;
      }
      userBar.hidden = false;
      if (currentUserLabel) {
        currentUserLabel.textContent = currentUser;
      }
    }

    function clearQuizUI() {
      if (summaryContainer) {
        summaryContainer.innerHTML = '';
      }
      if (questionContent) {
        questionContent.innerHTML = '';
      }
      toggleRetryButton(false);
      prevBtn.disabled = true;
      nextBtn.disabled = true;
      nextBtn.dataset.mode = 'check';
      nextBtn.textContent = 'Siguiente';
      updateResults();
      updateNavigation();
    }

    function getInitialStateForNewUser(database) {
      const users = database?.users ?? {};
      const existingUsers = Object.keys(users).length;
      if (existingUsers === 0) {
        const legacyState = readLegacyState();
        if (legacyState) {
          clearLegacyState();
          return createStateSnapshot(legacyState);
        }
      }
      return createDefaultState();
    }

    function readLegacyState() {
      try {
        const stored = localStorage.getItem(LEGACY_STORAGE_KEY);
        if (!stored) {
          return null;
        }
        return JSON.parse(stored);
      } catch (error) {
        console.warn('No se pudo leer el progreso guardado previamente:', error);
        return null;
      }
    }

    function clearLegacyState() {
      try {
        localStorage.removeItem(LEGACY_STORAGE_KEY);
      } catch (error) {
        console.warn('No se pudo limpiar el progreso anterior:', error);
      }
    }

    async function hashPassword(password) {
      try {
        if (window.crypto?.subtle && typeof TextEncoder !== 'undefined') {
          const encoder = new TextEncoder();
          const data = encoder.encode(password);
          const digest = await window.crypto.subtle.digest('SHA-256', data);
          return Array.from(new Uint8Array(digest))
            .map(byte => byte.toString(16).padStart(2, '0'))
            .join('');
        }
      } catch (error) {
        console.warn('No se pudo generar un hash seguro, se utilizar√° una codificaci√≥n simple.', error);
      }
      return Array.from(password)
        .map(char => char.charCodeAt(0).toString(16).padStart(2, '0'))
        .join('');
    }

    function normalizeQuestions(rawQuestions) {
      return rawQuestions.map((raw, index) => {
        const baseId = typeof raw.id === 'number' || typeof raw.id === 'string' ? raw.id : index + 1;
        const questionId = `q${baseId}`;
        const base = {
          id: questionId,
          type: raw.type,
          prompt: raw.prompt ?? raw.title ?? '',
          explanation: raw.explanation ?? '',
          helper: raw.helper ?? null
        };

        switch (raw.type) {
          case 'single': {
            const options = createOptionObjects(raw.options);
            const correctIndex = Array.isArray(raw.correct) ? raw.correct[0] : raw.correct;
            return {
              ...base,
              type: 'single',
              options,
              correct: toStringIndex(correctIndex)
            };
          }
          case 'multi': {
            if (Array.isArray(raw.subitems)) {
              const statements = raw.subitems.map((text, idx) => ({
                id: `${questionId}-s${idx}`,
                text,
                correct: Array.isArray(raw.correct) ? Boolean(raw.correct[idx]) : Boolean(raw.correct)
              }));
              return {
                ...base,
                type: 'group_tf',
                statements
              };
            }
            const options = createOptionObjects(raw.options);
            const correctValues = Array.isArray(raw.correct)
              ? raw.correct.map(value => toStringIndex(value)).filter(value => value !== '')
              : [];
            return {
              ...base,
              type: 'multi',
              options,
              correct: correctValues
            };
          }
          case 'tf': {
            return {
              ...base,
              type: 'tf',
              options: [
                { value: 'true', label: 'Verdadero' },
                { value: 'false', label: 'Falso' }
              ],
              correct: raw.correct ? 'true' : 'false'
            };
          }
          case 'match': {
            return {
              ...base,
              type: 'match',
              pairs: normalizeMatchPairs(raw)
            };
          }
          default: {
            const options = createOptionObjects(raw.options);
            const correct = Array.isArray(raw.correct)
              ? raw.correct.map(value => toStringIndex(value)).filter(value => value !== '')
              : toStringIndex(raw.correct);
            return {
              ...base,
              options,
              correct
            };
          }
        }
      });
    }

    function createOptionObjects(optionList) {
      if (!Array.isArray(optionList)) {
        return [];
      }
      return optionList.map((label, idx) => ({
        value: toStringIndex(idx),
        label
      }));
    }

    function normalizeMatchPairs(raw) {
      const rightOptions = Array.isArray(raw.right)
        ? raw.right.map((label, idx) => ({ value: toStringIndex(idx), label }))
        : [];
      const correctIndexes = Array.isArray(raw.correct) ? raw.correct : [];
      return Array.isArray(raw.left)
        ? raw.left.map((leftText, idx) => ({
            left: leftText,
            options: rightOptions.map(option => ({ ...option })),
            correct: toStringIndex(correctIndexes[idx])
          }))
        : [];
    }

    function toStringIndex(value) {
      if (value === null || value === undefined) {
        return '';
      }
      return String(value);
    }
    function init() {
      if (!currentUser) {
        return;
      }
      renderSummary();
      renderQuestion();
      updateResults();
    }

    function loadUserDatabase() {
      try {
        const stored = localStorage.getItem(USER_STORAGE_KEY);
        if (!stored) {
          return { currentUser: null, users: {} };
        }
        const parsed = JSON.parse(stored);
        const users = parsed && typeof parsed.users === 'object' && parsed.users !== null ? parsed.users : {};
        const storedUser = typeof parsed.currentUser === 'string' ? parsed.currentUser : null;
        return { currentUser: storedUser, users };
      } catch (error) {
        console.warn('No se pudo recuperar la informaci√≥n de usuarios:', error);
        return { currentUser: null, users: {} };
      }
    }

    function saveUserDatabase(database) {
      try {
        localStorage.setItem(USER_STORAGE_KEY, JSON.stringify(database));
      } catch (error) {
        console.warn('No se pudo guardar la informaci√≥n de usuarios:', error);
      }
    }

    function createDefaultState() {
      return {
        currentIndex: 0,
        answers: {},
        evaluations: {}
      };
    }

    function createStateSnapshot(sourceState) {
      const baseState = sourceState ?? createDefaultState();
      return {
        currentIndex: clampIndex(baseState.currentIndex ?? 0),
        answers: cloneAnswers(baseState.answers ?? {}),
        evaluations: cloneEvaluations(baseState.evaluations ?? {})
      };
    }

    function cloneAnswers(answers) {
      const result = {};
      Object.entries(answers ?? {}).forEach(([key, value]) => {
        if (Array.isArray(value)) {
          result[key] = [...value];
          return;
        }
        if (value && typeof value === 'object') {
          result[key] = { ...value };
          return;
        }
        if (value !== undefined) {
          result[key] = value;
        }
      });
      return result;
    }

    function cloneEvaluations(evaluations) {
      const result = {};
      Object.entries(evaluations ?? {}).forEach(([key, value]) => {
        if (!value) return;
        const correctAnswers = Array.isArray(value.correctAnswers)
          ? value.correctAnswers.map(item => (item && typeof item === 'object' ? { ...item } : item))
          : [];
        result[key] = {
          isCorrect: Boolean(value.isCorrect),
          correctAnswers,
          explanation: value.explanation ?? ''
        };
      });
      return result;
    }

    function loadState(username = currentUser, database = null) {
      const defaultState = createDefaultState();
      if (!username) {
        return defaultState;
      }
      const sourceDatabase = database ?? loadUserDatabase();
      const stored = sourceDatabase.users?.[username]?.state;
      if (!stored) {
        return defaultState;
      }
      return createStateSnapshot(stored);
    }

    function saveState() {
      if (!currentUser) {
        return;
      }
      const database = loadUserDatabase();
      const users = database.users ?? {};
      const existingRecord = users[currentUser] ?? {};
      users[currentUser] = {
        ...existingRecord,
        state: createStateSnapshot(state)
      };
      database.users = users;
      database.currentUser = currentUser;
      saveUserDatabase(database);
    }

    function resetQuiz() {
      if (!currentUser) {
        return;
      }
      state = createDefaultState();
      saveState();
      renderSummary();
      renderQuestion();
      updateResults();
      const main = document.querySelector('main.app');
      if (main) {
        main.scrollIntoView({ behavior: 'smooth', block: 'start' });
      }
    }

    function clampIndex(index) {
      if (typeof index !== 'number' || Number.isNaN(index)) {
        return 0;
      }
      return Math.min(Math.max(index, 0), questions.length - 1);
    }

    function goToQuestion(index) {
      if (!currentUser) {
        return;
      }
      state.currentIndex = clampIndex(index);
      saveState();
      renderQuestion();
      renderSummary();
    }

    function renderSummary() {
      summaryContainer.innerHTML = '';
      if (!currentUser) {
        return;
      }
      questions.forEach((question, idx) => {
        const button = document.createElement('button');
        button.type = 'button';
        button.className = 'summary-btn';
        button.textContent = idx + 1;
        const evaluation = state.evaluations[question.id];
        if (evaluation?.isCorrect) {
          button.classList.add('is-correct');
        } else if (evaluation && !evaluation.isCorrect) {
          button.classList.add('is-incorrect');
        }
        if (state.currentIndex === idx) {
          button.classList.add('is-active');
        }
        button.setAttribute('aria-label', `Ir a la pregunta ${idx + 1}`);
        button.addEventListener('click', () => {
          goToQuestion(idx);
        });
        summaryContainer.appendChild(button);
      });
    }

    function renderQuestion() {
      if (!currentUser) {
        questionContent.innerHTML = '';
        prevBtn.disabled = true;
        nextBtn.disabled = true;
        toggleRetryButton(false);
        return;
      }
      const question = questions[state.currentIndex];
      if (!question) return;

      questionContent.innerHTML = '';
      const titleId = `${question.id}-title`;
      const evaluation = state.evaluations[question.id];
      const storedAnswer = state.answers[question.id];
      const isLocked = Boolean(evaluation);

      const promptText = question.prompt ?? question.title ?? '';
      const helperText = question.helper ?? '';
      const helperId = helperText ? `${question.id}-helper` : undefined;

      const header = document.createElement('div');
      header.className = 'question-header';
      header.innerHTML = `
        <div class="question-meta">
          <span class="chip">${typeLabels[question.type] ?? 'Pregunta'}</span>
          <span class="counter">Pregunta ${state.currentIndex + 1} de ${questions.length}</span>
        </div>
        <h2 class="question-title" id="${titleId}">${promptText}</h2>
        ${helperText ? `<p class="question-helper" id="${helperId}">${helperText}</p>` : ''}
      `;
      questionContent.appendChild(header);

      const optionsWrapper = document.createElement('div');
      optionsWrapper.className = 'options-wrapper';
      const role = question.type === 'single' || question.type === 'tf' ? 'radiogroup' : 'group';
      optionsWrapper.setAttribute('role', role);
      optionsWrapper.setAttribute('aria-labelledby', titleId);
      if (helperId) {
        optionsWrapper.setAttribute('aria-describedby', helperId);
      }
      questionContent.appendChild(optionsWrapper);

      if (question.type === 'match') {
        question.pairs.forEach(pair => {
          const row = document.createElement('div');
          row.className = 'match-row';
          row.dataset.left = pair.left;

          const label = document.createElement('span');
          label.className = 'match-term';
          label.textContent = pair.left;

          const select = document.createElement('select');
          select.dataset.left = pair.left;
          const placeholderOption = document.createElement('option');
          placeholderOption.value = '';
          placeholderOption.textContent = 'Seleccion√° una opci√≥n';
          select.appendChild(placeholderOption);

          pair.options.forEach(option => {
            const optEl = document.createElement('option');
            optEl.value = option.value;
            optEl.textContent = option.label;
            select.appendChild(optEl);
          });

          if (storedAnswer && storedAnswer[pair.left]) {
            select.value = storedAnswer[pair.left];
          }
          if (isLocked) {
            select.disabled = true;
          }

          const helper = document.createElement('span');
          helper.className = 'match-answer';
          helper.setAttribute('aria-hidden', 'true');

          row.append(label, select, helper);
          optionsWrapper.appendChild(row);

          if (!isLocked) {
            select.addEventListener('change', () => {
              const answer = collectMatchAnswer(false);
              recordAnswer(question, answer);
              if (!state.evaluations[question.id]) {
                updateFeedbackUI(question, null);
              }
            });
          }
        });
      } else if (question.type === 'group_tf') {
        question.statements.forEach((statement, idx) => {
          const row = document.createElement('div');
          row.className = 'match-row group-tf-row';
          row.dataset.index = String(idx);
          row.dataset.question = question.id;

          const term = document.createElement('span');
          term.className = 'match-term';
          term.textContent = statement.text;

          const controls = document.createElement('div');
          controls.className = 'group-tf-controls';

          ['true', 'false'].forEach(value => {
            const optionLabel = document.createElement('label');
            optionLabel.className = 'group-tf-option';

            const input = document.createElement('input');
            input.type = 'radio';
            input.name = `${question.id}-${idx}`;
            input.value = value;

            if (Array.isArray(storedAnswer) && storedAnswer[idx] === value) {
              input.checked = true;
            }
            if (isLocked) {
              input.disabled = true;
            }

            const text = document.createElement('span');
            text.textContent = value === 'true' ? 'Verdadero (V)' : 'Falso (F)';

            optionLabel.append(input, text);
            controls.appendChild(optionLabel);

            if (!isLocked) {
              input.addEventListener('change', () => {
                updateGroupTfOptionState(controls);
                const answer = collectGroupTfAnswer(question, false);
                recordAnswer(question, answer);
                if (!state.evaluations[question.id]) {
                  updateFeedbackUI(question, null);
                }
              });
            }
          });

          const helper = document.createElement('span');
          helper.className = 'match-answer';
          helper.setAttribute('aria-hidden', 'true');

          row.append(term, controls, helper);
          optionsWrapper.appendChild(row);

          updateGroupTfOptionState(controls);

          if (isLocked) {
            row.classList.add('is-locked');
          }
        });
      } else {
        const isMulti = question.type === 'multi';
        question.options.forEach(option => {
          const label = document.createElement('label');
          label.className = 'option-card option-card--' + question.type;
          label.dataset.value = option.value;

          const input = document.createElement('input');
          input.type = isMulti ? 'checkbox' : 'radio';
          input.name = question.id;
          input.value = option.value;
          if (isMulti && Array.isArray(storedAnswer) && storedAnswer.includes(option.value)) {
            input.checked = true;
          }
          if (!isMulti && storedAnswer === option.value) {
            input.checked = true;
          }
          if (isLocked) {
            input.disabled = true;
            label.classList.add('is-locked');
          }

          const indicator = document.createElement('span');
          indicator.className = 'option-indicator';

          const textWrapper = document.createElement('span');
          textWrapper.className = 'option-text';
          const mainText = document.createElement('span');
          mainText.className = 'option-main';
          mainText.textContent = option.label;
          textWrapper.appendChild(mainText);

          label.append(input, indicator, textWrapper);
          optionsWrapper.appendChild(label);

          if (!isLocked) {
            if (isMulti) {
              input.addEventListener('change', () => {
                const selectedValues = collectMultiAnswer(question.id);
                recordAnswer(question, selectedValues);
                if (!state.evaluations[question.id]) {
                  updateFeedbackUI(question, null);
                }
              });
            } else {
              input.addEventListener('change', () => {
                if (input.checked) {
                  recordAnswer(question, option.value);
                  if (!state.evaluations[question.id]) {
                    updateFeedbackUI(question, null);
                  }
                }
              });
            }
          }
        });
      }

      const feedback = document.createElement('div');
      feedback.className = 'feedback-area';
      feedback.innerHTML = `
        <p class="feedback-message" id="feedbackMessage" role="status" aria-live="polite"></p>
        <p class="correct-answer" id="correctAnswer"></p>
        <p class="explanation-text" id="explanationText"></p>
      `;
      questionContent.appendChild(feedback);

      if (evaluation && storedAnswer !== undefined) {
        showCorrection(question, evaluation, storedAnswer);
        updateFeedbackUI(question, evaluation);
      } else {
        updateFeedbackUI(question, null);
      }

      toggleRetryButton(isLocked);
      updateNavigation();
    }

    function applyEvaluation(question, rawAnswer) {
      if (!question || !currentUser) return;
      const storedAnswer = cloneAnswer(question, rawAnswer);
      const evaluation = evaluateQuestion(question, storedAnswer);

      state.answers[question.id] = storedAnswer;
      state.evaluations[question.id] = evaluation;
      saveState();

      showCorrection(question, evaluation, storedAnswer);
      updateFeedbackUI(question, evaluation);
      toggleRetryButton(true);
      renderSummary();
      updateResults();
      updateNavigation();
    }

    function recordAnswer(question, answer) {
      if (!question || !currentUser) return;
      const key = question.id;

      if (answer === null) {
        delete state.answers[key];
        saveState();
        return;
      }

      let shouldStore = true;
      if (Array.isArray(answer)) {
        shouldStore = answer.some(value => value !== null && value !== undefined && value !== '');
      } else if (typeof answer === 'object') {
        const values = Object.values(answer ?? {});
        shouldStore = values.some(value => value !== null && value !== undefined && value !== '');
      }

      if (!shouldStore) {
        delete state.answers[key];
      } else {
        state.answers[key] = cloneAnswer(question, answer);
      }
      saveState();
    }

    function cloneAnswer(question, answer) {
      if (question.type === 'multi') {
        return Array.isArray(answer) ? [...answer] : [];
      }
      if (question.type === 'group_tf') {
        return Array.isArray(answer) ? [...answer] : [];
      }
      if (question.type === 'match') {
        return answer ? { ...answer } : {};
      }
      return typeof answer === 'string' ? answer : null;
    }

    function evaluateQuestion(question, userAnswer) {
      let isCorrect = false;
      let correctAnswers;

      switch (question.type) {
        case 'single':
        case 'tf': {
          const correctValue = Array.isArray(question.correct) ? question.correct[0] : question.correct;
          isCorrect = userAnswer === correctValue;
          correctAnswers = Array.isArray(question.correct) ? [...question.correct] : [question.correct];
          break;
        }
        case 'multi': {
          const expected = Array.isArray(question.correct) ? [...question.correct].sort() : [];
          const received = Array.isArray(userAnswer) ? [...userAnswer].sort() : [];
          isCorrect = expected.length === received.length && expected.every((value, idx) => value === received[idx]);
          correctAnswers = expected;
          break;
        }
        case 'group_tf': {
          const expected = Array.isArray(question.statements)
            ? question.statements.map(item => Boolean(item.correct))
            : [];
          const received = Array.isArray(userAnswer)
            ? expected.map((_, idx) => userAnswer[idx] === 'true')
            : [];
          isCorrect = expected.length === received.length && expected.every((value, idx) => received[idx] === value);
          correctAnswers = expected;
          break;
        }
        case 'match': {
          correctAnswers = question.pairs.map(pair => ({ left: pair.left, value: pair.correct }));
          const provided = userAnswer || {};
          isCorrect = question.pairs.every(pair => provided[pair.left] === pair.correct);
          break;
        }
        default:
          correctAnswers = [];
      }

      return {
        isCorrect,
        correctAnswers,
        explanation: question.explanation
      };
    }

    function showCorrection(question, evaluation, userAnswer) {
      const correctAnswers = evaluation.correctAnswers;
      if (question.type === 'match') {
        const rows = questionContent.querySelectorAll('.match-row');
        rows.forEach(row => {
          const key = row.dataset.left;
          const select = row.querySelector('select');
          const helper = row.querySelector('.match-answer');
          const expected = correctAnswers.find(item => item.left === key);
          if (select) {
            select.disabled = true;
          }
          if (helper && expected) {
            helper.textContent = `Correcta: ${getMatchLabel(question, key, expected.value)}`;
            row.classList.add('show-answer');
          }
          if (userAnswer && userAnswer[key] === expected?.value) {
            row.classList.add('is-correct');
          } else {
            row.classList.add('is-incorrect');
          }
        });
      } else if (question.type === 'group_tf') {
        const rows = questionContent.querySelectorAll('.group-tf-row');
        rows.forEach(row => {
          const index = Number(row.dataset.index ?? -1);
          const helper = row.querySelector('.match-answer');
          const controls = row.querySelector('.group-tf-controls');
          const expectedValue = correctAnswers[index] ? 'true' : 'false';
          const selectedValue = Array.isArray(userAnswer) ? userAnswer[index] : undefined;

          row.classList.add('show-answer', 'is-locked');

          row.querySelectorAll('input').forEach(input => {
            input.disabled = true;
          });

          if (controls) {
            updateGroupTfOptionState(controls);
          }

          if (helper && correctAnswers[index] !== undefined) {
            helper.textContent = `Correcta: ${correctAnswers[index] ? 'Verdadero' : 'Falso'}`;
          }

          const expectedOption = row.querySelector(`.group-tf-option input[value="${expectedValue}"]`);
          if (expectedOption?.parentElement) {
            expectedOption.parentElement.classList.remove('is-active');
            expectedOption.parentElement.classList.add('show-correct', 'is-correct');
          }

          if (selectedValue) {
            const selectedOption = row.querySelector(`.group-tf-option input[value="${selectedValue}"]`);
            if (selectedOption?.parentElement) {
              selectedOption.parentElement.classList.remove('is-active');
              if (selectedValue === expectedValue) {
                selectedOption.parentElement.classList.add('is-correct');
              } else {
                selectedOption.parentElement.classList.add('is-incorrect');
              }
            }
          }

          if (selectedValue === expectedValue) {
            row.classList.add('is-correct');
          } else {
            row.classList.add('is-incorrect');
          }
        });
      } else {
        const selectedValues = Array.isArray(userAnswer) ? userAnswer : userAnswer ? [userAnswer] : [];
        const cards = questionContent.querySelectorAll('.option-card');
        cards.forEach(card => {
          const value = card.dataset.value;
          const input = card.querySelector('input');
          if (input) {
            input.disabled = true;
          }
          card.classList.add('is-locked');
          if (selectedValues.includes(value)) {
            card.classList.add(correctAnswers.includes(value) ? 'is-correct' : 'is-incorrect');
          }
          if (correctAnswers.includes(value)) {
            card.classList.add('show-correct');
          }
        });
      }
    }

    function updateFeedbackUI(question, evaluation) {
      const feedbackMessage = document.getElementById('feedbackMessage');
      const correctAnswerEl = document.getElementById('correctAnswer');
      const explanationEl = document.getElementById('explanationText');
      if (!feedbackMessage || !correctAnswerEl || !explanationEl) return;

      if (!evaluation) {
        feedbackMessage.textContent = 'Seleccion√° una respuesta y presion√° "Siguiente" para corregirla.';
        feedbackMessage.className = 'feedback-message';
        correctAnswerEl.textContent = '';
        explanationEl.textContent = '';
        return;
      }

      feedbackMessage.textContent = evaluation.isCorrect
        ? '¬°Correcto! Pod√©s avanzar con "Siguiente".'
        : 'Respuesta incorrecta. Revis√° la explicaci√≥n y luego presion√° "Siguiente" para continuar.';
      feedbackMessage.className = 'feedback-message ' + (evaluation.isCorrect ? 'success' : 'error');
      correctAnswerEl.textContent = 'Respuesta correcta: ' + formatCorrectAnswer(question, evaluation);
      explanationEl.textContent = evaluation.explanation;
    }

    function showIncompleteAnswerMessage() {
      const feedbackMessage = document.getElementById('feedbackMessage');
      const correctAnswerEl = document.getElementById('correctAnswer');
      const explanationEl = document.getElementById('explanationText');
      if (!feedbackMessage || !correctAnswerEl || !explanationEl) return;

      feedbackMessage.textContent = 'Complet√° la respuesta antes de continuar.';
      feedbackMessage.className = 'feedback-message warning';
      correctAnswerEl.textContent = '';
      explanationEl.textContent = '';
    }

    function toggleRetryButton(show) {
      if (show) {
        retryButton.hidden = false;
        retryButton.disabled = false;
      } else {
        retryButton.hidden = true;
        retryButton.disabled = true;
      }
    }

    function updateNavigation() {
      if (!currentUser) {
        prevBtn.disabled = true;
        nextBtn.disabled = true;
        nextBtn.dataset.mode = 'check';
        nextBtn.textContent = 'Siguiente';
        return;
      }

      prevBtn.disabled = state.currentIndex === 0;
      const question = questions[state.currentIndex];
      if (!question) {
        nextBtn.disabled = true;
        nextBtn.dataset.mode = 'check';
        nextBtn.textContent = 'Siguiente';
        return;
      }
      nextBtn.disabled = false;
      const hasEvaluation = question ? Boolean(state.evaluations[question.id]) : false;

      if (!hasEvaluation) {
        nextBtn.dataset.mode = 'check';
        nextBtn.textContent = 'Siguiente';
        return;
      }

      if (state.currentIndex === questions.length - 1) {
        nextBtn.dataset.mode = 'results';
        nextBtn.textContent = 'Ver resultados';
      } else {
        nextBtn.dataset.mode = 'next';
        nextBtn.textContent = 'Siguiente';
      }
    }

    function updateResults() {
      if (!currentUser) {
        const total = questions.length;
        scoreCountEl.textContent = `0 / ${total}`;
        scorePercentageEl.textContent = '0%';
        scoreBadgeEl.textContent = getBadgeLabel(0);
        return;
      }
      const evaluations = Object.values(state.evaluations);
      const correctCount = evaluations.filter(entry => entry?.isCorrect).length;
      const total = questions.length;
      const percentage = total === 0 ? 0 : Math.round((correctCount / total) * 100);

      scoreCountEl.textContent = `${correctCount} / ${total}`;
      scorePercentageEl.textContent = `${percentage}%`;
      scoreBadgeEl.textContent = getBadgeLabel(percentage);
    }

    function getBadgeLabel(percentage) {
      if (percentage >= 90) return 'Excelente';
      if (percentage >= 75) return 'Muy bien';
      return 'A seguir';
    }

    function formatCorrectAnswer(question, evaluation) {
      if (question.type === 'match') {
        return evaluation.correctAnswers
          .map(item => `${item.left} ‚Üí ${getMatchLabel(question, item.left, item.value)}`)
          .join('; ');
      }
      if (question.type === 'group_tf') {
        const statements = Array.isArray(question.statements) ? question.statements : [];
        return statements
          .map((statement, idx) => {
            const expected = evaluation.correctAnswers?.[idx];
            const label = expected ? 'Verdadero' : 'Falso';
            return `${statement.text ?? `Enunciado ${idx + 1}`} ‚Üí ${label}`;
          })
          .join('; ');
      }
      const optionMap = new Map();
      if (Array.isArray(question.options)) {
        question.options.forEach(option => {
          optionMap.set(option.value, option.label);
        });
      }
      return evaluation.correctAnswers
        .map(value => optionMap.get(value) ?? value)
        .join(', ');
    }

    function getMatchLabel(question, left, value) {
      const pair = question.pairs.find(item => item.left === left);
      if (!pair) return value;
      const option = pair.options.find(opt => opt.value === value);
      return option ? option.label : value;
    }

    function collectCurrentAnswer(question, requireComplete = false) {
      if (!question) return null;
      switch (question.type) {
        case 'single':
        case 'tf': {
          const selected = questionContent.querySelector(`input[name="${question.id}"]:checked`);
          return selected ? selected.value : null;
        }
        case 'multi': {
          const values = collectMultiAnswer(question.id);
          if (requireComplete && values.length === 0) {
            return null;
          }
          return values;
        }
        case 'group_tf': {
          return collectGroupTfAnswer(question, requireComplete);
        }
        case 'match': {
          return collectMatchAnswer(requireComplete);
        }
        default:
          return null;
      }
    }

    function collectGroupTfAnswer(question, requireComplete = true) {
      if (!question) {
        return requireComplete ? null : [];
      }
      const rows = questionContent.querySelectorAll(`.group-tf-row[data-question="${question.id}"]`);
      const answer = [];
      let filled = true;
      rows.forEach(row => {
        const index = Number(row.dataset.index ?? -1);
        const checked = row.querySelector('input:checked');
        if (!checked) {
          filled = false;
          answer[index] = null;
          return;
        }
        answer[index] = checked.value;
      });
      if (requireComplete && !filled) {
        return null;
      }
      return answer;
    }

    function updateGroupTfOptionState(container) {
      if (!container) return;
      container.querySelectorAll('.group-tf-option').forEach(option => {
        const input = option.querySelector('input');
        option.classList.toggle('is-active', Boolean(input?.checked));
      });
    }

    function collectMultiAnswer(questionId) {
      return Array.from(document.querySelectorAll(`input[name="${questionId}"]:checked`)).map(input => input.value);
    }

    function collectMatchAnswer(requireComplete = true) {
      const rows = questionContent.querySelectorAll('.match-row');
      const answer = {};
      let filled = true;
      rows.forEach(row => {
        const select = row.querySelector('select');
        const key = select?.dataset.left;
        if (!key) return;
        const value = select?.value || null;
        if (!value) {
          filled = false;
        }
        answer[key] = value;
      });
      if (requireComplete && !filled) {
        return null;
      }
      return answer;
    }

  </script>
</body>
</html>
