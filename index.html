<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Evaluación interactiva de termodinámica</title>
  <style>
    :root {
      --bg-gradient-start: #f5f7ff;
      --bg-gradient-end: #dfe7fd;
      --card-bg: #ffffff;
      --primary: #6366f1;
      --primary-dark: #4f46e5;
      --text: #1f2937;
      --muted: #6b7280;
      --border: #e2e8f0;
      --success: #22c55e;
      --success-bg: #ecfdf5;
      --error: #ef4444;
      --error-bg: #fee2e2;
      --shadow: 0 20px 45px -35px rgba(79, 70, 229, 0.65);
      --shadow-strong: 0 24px 54px -30px rgba(79, 70, 229, 0.35);
      --radius-lg: 22px;
      --radius-md: 16px;
      --radius-sm: 10px;
    }

    *, *::before, *::after {
      box-sizing: border-box;
    }

    html, body {
      margin: 0;
      padding: 0;
      font-family: "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
      background: linear-gradient(135deg, var(--bg-gradient-start), var(--bg-gradient-end));
      color: var(--text);
      line-height: 1.6;
      min-height: 100%;
    }

    body {
      display: flex;
      justify-content: center;
    }

    main.app {
      width: min(1100px, 95vw);
      padding: 2.5rem 1.25rem 3rem;
    }

    .app-header {
      text-align: center;
      margin-bottom: 2.25rem;
    }

    .app-header h1 {
      margin: 0;
      font-size: clamp(1.8rem, 2.5vw, 2.4rem);
      letter-spacing: -0.02em;
    }

    .app-header p {
      margin: 0.75rem auto 0;
      max-width: 640px;
      color: var(--muted);
      font-size: 1rem;
    }

    .layout {
      display: flex;
      gap: 1.75rem;
      align-items: flex-start;
    }

    .summary-panel {
      flex: 0 0 240px;
      background: rgba(255, 255, 255, 0.8);
      backdrop-filter: blur(6px);
      border-radius: var(--radius-lg);
      padding: 1.75rem 1.5rem;
      box-shadow: var(--shadow);
      position: sticky;
      top: 1.5rem;
    }

    .summary-panel h2 {
      margin: 0 0 1rem;
      font-size: 1.1rem;
      letter-spacing: 0.02em;
      text-transform: uppercase;
      color: var(--muted);
    }

    .summary-buttons {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(60px, 1fr));
      gap: 0.65rem;
    }

    .summary-btn {
      border: none;
      border-radius: 999px;
      padding: 0.65rem 0;
      background: #eef2ff;
      color: var(--primary-dark);
      font-weight: 600;
      letter-spacing: 0.03em;
      cursor: pointer;
      transition: transform 0.18s ease, box-shadow 0.18s ease, background 0.18s ease;
      box-shadow: 0 12px 24px -18px rgba(79, 70, 229, 0.65);
    }

    .summary-btn:hover {
      transform: translateY(-1px);
    }

    .summary-btn:focus-visible {
      outline: 3px solid rgba(99, 102, 241, 0.35);
      outline-offset: 2px;
    }

    .summary-btn.is-active {
      background: var(--primary);
      color: #ffffff;
      box-shadow: 0 18px 32px -20px rgba(79, 70, 229, 0.7);
      transform: translateY(-1px);
    }

    .summary-btn.is-correct {
      background: rgba(34, 197, 94, 0.15);
      color: #047857;
    }

    .summary-btn.is-incorrect {
      background: rgba(239, 68, 68, 0.15);
      color: #b91c1c;
    }

    .summary-btn.is-active.is-correct,
    .summary-btn.is-active.is-incorrect {
      background: var(--primary);
      color: #ffffff;
    }

    .question-card {
      flex: 1;
      background: rgba(255, 255, 255, 0.95);
      border-radius: var(--radius-lg);
      box-shadow: var(--shadow-strong);
      padding: 2rem 2.25rem;
      display: flex;
      flex-direction: column;
      gap: 1.5rem;
    }

    .question-header {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    .question-meta {
      display: flex;
      align-items: center;
      justify-content: space-between;
      flex-wrap: wrap;
      gap: 0.75rem;
    }

    .chip {
      background: rgba(99, 102, 241, 0.12);
      color: var(--primary-dark);
      border-radius: 999px;
      padding: 0.35rem 0.85rem;
      font-size: 0.85rem;
      font-weight: 600;
      letter-spacing: 0.02em;
    }

    .counter {
      color: var(--muted);
      font-weight: 600;
      font-size: 0.95rem;
    }

    .question-title {
      margin: 0;
      font-size: clamp(1.3rem, 2.2vw, 1.75rem);
      line-height: 1.4;
    }

    .question-helper {
      margin: 0;
      color: var(--muted);
      font-size: 0.95rem;
    }

    .options-wrapper {
      display: flex;
      flex-direction: column;
      gap: 0.9rem;
    }

    .option-card {
      position: relative;
      display: flex;
      align-items: flex-start;
      gap: 1rem;
      padding: 1rem 1.25rem;
      background: var(--card-bg);
      border-radius: var(--radius-md);
      border: 1px solid var(--border);
      box-shadow: 0 14px 36px -28px rgba(15, 23, 42, 0.3);
      cursor: pointer;
      transition: transform 0.2s ease, box-shadow 0.2s ease, border 0.2s ease, background 0.2s ease;
      min-height: 64px;
    }

    .option-card:hover {
      transform: translateY(-2px);
      box-shadow: 0 18px 40px -26px rgba(79, 70, 229, 0.45);
    }

    .option-card:focus-within {
      outline: 3px solid rgba(99, 102, 241, 0.3);
      outline-offset: 2px;
    }

    .option-card.is-locked {
      cursor: default;
      pointer-events: none;
      opacity: 0.92;
    }

    .option-card input {
      position: absolute;
      opacity: 0;
      pointer-events: none;
    }

    .option-indicator {
      width: 22px;
      height: 22px;
      border: 2px solid var(--border);
      border-radius: 50%;
      display: grid;
      place-items: center;
      margin-top: 0.1rem;
      flex-shrink: 0;
      transition: border 0.2s ease, background 0.2s ease;
    }

    .option-card--multi .option-indicator {
      border-radius: 8px;
    }

    .option-indicator::after {
      content: "";
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: var(--primary);
      transform: scale(0);
      transition: transform 0.2s ease, opacity 0.2s ease;
      opacity: 0;
    }

    .option-card--multi .option-indicator::after {
      content: "✓";
      width: auto;
      height: auto;
      color: #ffffff;
      font-weight: 700;
      font-size: 0.75rem;
      transform: scale(0);
    }

    .option-card input:checked + .option-indicator {
      border-color: var(--primary);
      background: var(--primary);
    }

    .option-card input:checked + .option-indicator::after {
      transform: scale(1);
      opacity: 1;
    }

    .option-text {
      display: flex;
      flex-direction: column;
      gap: 0.3rem;
      color: var(--text);
    }

    .option-main {
      font-weight: 600;
      font-size: 1rem;
    }

    .option-sub {
      font-size: 0.9rem;
      color: var(--muted);
    }

    .option-card.is-correct {
      border-color: var(--success);
      background: var(--success-bg);
      box-shadow: 0 18px 45px -30px rgba(34, 197, 94, 0.45);
    }

    .option-card.is-incorrect {
      border-color: var(--error);
      background: var(--error-bg);
      box-shadow: 0 18px 45px -30px rgba(239, 68, 68, 0.35);
    }

    .option-card.show-correct:not(.is-correct) {
      border-style: dashed;
      border-color: rgba(34, 197, 94, 0.8);
      background: #f1fdf3;
    }

    .option-card.is-incorrect .option-indicator,
    .option-card.is-incorrect input:checked + .option-indicator {
      border-color: var(--error);
      background: var(--error);
    }

    .option-card.is-correct .option-indicator,
    .option-card.is-correct input:checked + .option-indicator {
      border-color: var(--success);
      background: var(--success);
    }

    .match-row {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem 1rem;
      align-items: center;
      background: var(--card-bg);
      border: 1px solid var(--border);
      border-radius: var(--radius-md);
      padding: 0.9rem 1.15rem;
      box-shadow: 0 14px 36px -28px rgba(15, 23, 42, 0.28);
      transition: border 0.2s ease, background 0.2s ease, box-shadow 0.2s ease;
    }

    .match-row select {
      flex: 1;
      min-width: 220px;
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      padding: 0.55rem 0.65rem;
      font-size: 0.95rem;
      color: var(--text);
      background: #f8fafc;
      transition: border 0.2s ease, box-shadow 0.2s ease;
    }

    .match-row select:focus-visible {
      outline: 3px solid rgba(99, 102, 241, 0.28);
      outline-offset: 2px;
      border-color: var(--primary);
    }

    .match-term {
      font-weight: 600;
      color: var(--text);
      min-width: 130px;
      flex: 1 1 260px;
    }

    .match-answer {
      font-size: 0.85rem;
      color: var(--muted);
      margin-left: auto;
      opacity: 0;
      transform: translateY(-4px);
      transition: opacity 0.2s ease, transform 0.2s ease, color 0.2s ease;
    }

    .match-row.show-answer .match-answer {
      opacity: 1;
      transform: translateY(0);
      color: var(--text);
      font-weight: 600;
    }

    .match-row.is-correct {
      border-color: var(--success);
      background: var(--success-bg);
      box-shadow: 0 18px 45px -32px rgba(34, 197, 94, 0.45);
    }

    .match-row.is-incorrect {
      border-color: var(--error);
      background: var(--error-bg);
      box-shadow: 0 18px 45px -32px rgba(239, 68, 68, 0.35);
    }

    .group-tf-row {
      align-items: flex-start;
    }

    .group-tf-controls {
      display: flex;
      gap: 0.75rem;
      flex-wrap: wrap;
      margin-left: auto;
    }

    .group-tf-option {
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
      font-weight: 600;
      color: var(--text);
      background: #f8fafc;
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      padding: 0.35rem 0.75rem;
      cursor: pointer;
      transition: background 0.2s ease, border 0.2s ease, color 0.2s ease;
    }

    .group-tf-option:hover {
      border-color: var(--primary);
    }

    .group-tf-option input {
      accent-color: var(--primary);
    }

    .group-tf-option.is-active {
      border-color: var(--primary);
      background: rgba(99, 102, 241, 0.15);
      color: var(--primary-dark);
    }

    .group-tf-option.is-correct,
    .group-tf-option.show-correct {
      border-color: var(--success);
      background: var(--success-bg);
      color: #047857;
    }

    .group-tf-option.is-incorrect {
      border-color: var(--error);
      background: var(--error-bg);
      color: #b91c1c;
    }

    .group-tf-row.is-locked .group-tf-option {
      cursor: default;
      opacity: 0.95;
    }

    .feedback-area {
      border-top: 1px solid rgba(148, 163, 184, 0.2);
      padding-top: 1.25rem;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      min-height: 92px;
    }

    .feedback-message {
      margin: 0;
      font-weight: 600;
      color: var(--muted);
    }

    .feedback-message.success {
      color: #047857;
    }

    .feedback-message.error {
      color: #b91c1c;
    }

    .correct-answer,
    .explanation-text {
      margin: 0;
      color: var(--muted);
      font-size: 0.95rem;
    }

    .explanation-text {
      color: #475569;
    }

    .question-footer {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 1rem;
      flex-wrap: wrap;
    }

    .retry-btn {
      background: rgba(99, 102, 241, 0.12);
      color: var(--primary-dark);
      border: none;
      border-radius: 999px;
      padding: 0.6rem 1.2rem;
      font-weight: 600;
      letter-spacing: 0.02em;
      cursor: pointer;
      transition: background 0.2s ease, transform 0.2s ease;
    }

    .retry-btn:hover {
      background: rgba(99, 102, 241, 0.2);
      transform: translateY(-1px);
    }

    .retry-btn:disabled,
    .retry-btn[hidden] {
      display: none;
    }

    .nav-buttons {
      display: flex;
      gap: 0.75rem;
    }

    .nav-btn {
      border: none;
      border-radius: 999px;
      padding: 0.75rem 1.5rem;
      font-weight: 600;
      letter-spacing: 0.03em;
      cursor: pointer;
      background: var(--primary);
      color: #ffffff;
      transition: background 0.2s ease, transform 0.2s ease, box-shadow 0.2s ease;
      box-shadow: 0 18px 40px -28px rgba(79, 70, 229, 0.7);
    }

    .nav-btn:hover {
      background: var(--primary-dark);
      transform: translateY(-1px);
    }

    .nav-btn:disabled {
      background: rgba(99, 102, 241, 0.25);
      cursor: not-allowed;
      box-shadow: none;
    }

    button:focus-visible {
      outline: 3px solid rgba(99, 102, 241, 0.4);
      outline-offset: 2px;
    }

    .results-card {
      margin-top: 2.5rem;
      background: rgba(255, 255, 255, 0.92);
      padding: 2rem;
      border-radius: var(--radius-lg);
      box-shadow: var(--shadow);
      text-align: center;
      display: flex;
      flex-direction: column;
      gap: 0.6rem;
    }

    .results-card h2 {
      margin: 0;
      letter-spacing: 0.02em;
    }

    .score-line {
      margin: 0;
      font-size: 1.05rem;
      font-weight: 600;
      color: var(--text);
    }

    .score-percentage {
      margin: 0;
      font-size: 2rem;
      font-weight: 700;
      letter-spacing: -0.02em;
      color: var(--primary-dark);
    }

    .badge {
      display: inline-flex;
      align-self: center;
      align-items: center;
      justify-content: center;
      padding: 0.45rem 1.25rem;
      background: rgba(99, 102, 241, 0.18);
      color: var(--primary-dark);
      border-radius: 999px;
      font-weight: 600;
      letter-spacing: 0.05em;
      text-transform: uppercase;
    }

    .resume-note {
      margin: 0.75rem 0 0;
      color: var(--muted);
      font-size: 0.9rem;
    }

    @media (max-width: 960px) {
      .layout {
        flex-direction: column;
      }

      .summary-panel {
        width: 100%;
        position: static;
        order: 2;
      }

      .question-card {
        order: 1;
        padding: 1.75rem 1.5rem;
      }

      .match-row {
        flex-direction: column;
        align-items: flex-start;
      }

      .match-row select {
        width: 100%;
      }

      .match-answer {
        margin-left: 0;
      }
    }

    @media (max-width: 600px) {
      main.app {
        width: 100%;
        padding: 1.75rem 1rem 2.5rem;
      }

      .summary-buttons {
        grid-template-columns: repeat(auto-fit, minmax(56px, 1fr));
      }

      .question-card {
        padding: 1.5rem 1.2rem;
      }

      .nav-buttons {
        width: 100%;
        justify-content: space-between;
      }

      .nav-btn {
        flex: 1;
      }

      .group-tf-controls {
        width: 100%;
        margin-left: 0;
        justify-content: flex-start;
      }
    }
  </style>
</head>
<body>
  <main class="app">
    <header class="app-header">
      <h1>Evaluación interactiva de termodinámica y diseño de ingeniería</h1>
      <p>Respondé las preguntas y obtené retroalimentación inmediata. Podés navegar por el resumen, y tu progreso se guardará automáticamente en este dispositivo.</p>
    </header>
    <div class="layout">
      <aside class="summary-panel" aria-label="Resumen de preguntas">
        <h2>Resumen</h2>
        <div class="summary-buttons" id="summaryButtons"></div>
      </aside>
      <section class="question-card" id="questionCard" aria-live="polite">
        <div id="questionContent"></div>
        <div class="question-footer">
          <button type="button" class="retry-btn" id="retryButton" hidden>Reintentar</button>
          <div class="nav-buttons">
            <button type="button" class="nav-btn" id="prevBtn">Anterior</button>
            <button type="button" class="nav-btn" id="nextBtn">Siguiente</button>
          </div>
        </div>
      </section>
    </div>
    <section class="results-card" id="resultsCard" aria-live="polite">
      <h2>Resultados</h2>
      <p class="score-line"><span id="scoreCount">0 / 0</span> respuestas correctas</p>
      <p class="score-percentage" id="scorePercentage">0%</p>
      <span class="badge" id="scoreBadge">A seguir</span>
      <p class="resume-note">Tus respuestas quedan guardadas localmente para que puedas continuar más tarde.</p>
    </section>
  </main>
  <script>
    const QUESTIONS = [
      {
        id: 1,
        type: 'multi',
        prompt: 'Seleccionar cuáles son los modos de transferencia de energía en termodinámica:',
        options: ['Energía Potencial', 'Trabajo', 'Energía Cinética', 'Energía Interna', 'Entropía', 'Calor'],
        correct: [1, 5],
        explanation: 'En termodinámica, la energía se transfiere como trabajo o como calor; las demás son formas almacenadas o propiedades.'
      },
      {
        id: 2,
        type: 'multi',
        prompt: 'Seleccionar cuáles son los modos de transferencia de calor:',
        options: ['Radiación', 'Convección', 'Evaporación', 'Fusión', 'Conducción'],
        correct: [0, 1, 4],
        explanation: 'Los mecanismos fundamentales de transferencia de calor son conducción, convección y radiación.'
      },
      {
        id: 3,
        type: 'tf',
        prompt: 'Según el convenio de signos, Q > 0 cuando el calor entra al sistema.',
        correct: true,
        explanation: 'Por convenio clásico, Q>0 hacia el sistema y Q<0 desde el sistema.'
      },
      {
        id: 4,
        type: 'multi',
        prompt: 'Ciclos utilizados solo en motores de combustión externa:',
        options: ['Ciclo Diésel', 'Ciclo Rankine', 'Ciclo Brayton', 'Ciclo Otto'],
        correct: [1],
        explanation: 'El ciclo Rankine (máquinas de vapor) es de combustión externa en su configuración típica.'
      },
      {
        id: 5,
        type: 'match',
        prompt: 'Emparejar cada principio con su definición:',
        left: [
          'Transferir calor de un cuerpo frío a uno caliente como único efecto es imposible.',
          'No existe ciclo que convierta íntegramente el calor absorbido en trabajo.',
          'Relación entre calor, trabajo y energía interna en un sistema.'
        ],
        right: [
          'Formulación de Clausius',
          'Enunciado de Kelvin–Planck',
          'Principio de conservación de la energía'
        ],
        correct: [0, 1, 2],
        explanation: 'Clausius prohíbe transferencia espontánea de frío a caliente; Kelvin–Planck prohíbe la conversión total de Q en W; el primero es la 1ª Ley.'
      },
      {
        id: 6,
        type: 'multi',
        prompt: 'Componentes principales de un motor de turbina de gas de ciclo abierto:',
        options: ['Cámara de combustión', 'Filtro', 'Turbina', 'Compresor', 'Trampa de agua', 'Bomba'],
        correct: [0, 2, 3],
        explanation: 'Las tres etapas básicas: compresor, combustor, turbina.'
      },
      {
        id: 7,
        type: 'single',
        prompt: '¿Cuál curva corresponde a un ciclo de Carnot?',
        options: ['Dos isotermas y dos isobaras', 'Dos isobaras y dos adiabáticas', 'Dos isotermas y dos isocoras', 'Dos isotermas y dos adiabáticas'],
        correct: 3,
        explanation: 'Carnot se compone de dos procesos isotermos y dos adiabáticos reversibles.'
      },
      {
        id: 8,
        type: 'multi',
        prompt: 'Seleccione cuáles son etapas de diseño en ingeniería:',
        options: [
          'Identificar alternativas realizables',
          'Determinar restricciones y criterios',
          'Elegir la solución solo por menor costo',
          'Definir objetivos del diseño',
          'Concretar especificaciones cualitativas'
        ],
        correct: [0, 1, 3, 4],
        explanation: 'Elegir solo por costo ignora criterios esenciales del diseño.'
      },
      {
        id: 9,
        type: 'tf',
        prompt: 'El rendimiento de un ciclo Ericsson ideal es el mismo que el de Carnot.',
        correct: true,
        explanation: 'Con regeneración ideal e isotermas, Ericsson alcanza la eficiencia de Carnot.'
      },
      {
        id: 10,
        type: 'match',
        prompt: 'Metodología: emparejar cada paso con su definición.',
        left: [
          'Establecer con tus palabras lo que debe calcularse.',
          'Listar consideraciones e idealizaciones.',
          'Establecer brevemente lo que es conocido.',
          'Dibujar el esquema y rotular datos.',
          'Expresar ecuaciones y relaciones y resolver.'
        ],
        right: [
          'Determinar lo que se debe hallar',
          'Establecer consideraciones e hipótesis',
          'Determinar lo conocido',
          'Determinar los datos y diagramas',
          'Realizar el análisis'
        ],
        correct: [0, 1, 2, 3, 4],
        explanation: 'Corresponde al flujo clásico de resolución de problemas en ingeniería.'
      },
      {
        id: 11,
        type: 'match',
        prompt: 'Ordenar los pasos (1→5).',
        left: [
          'Paso 5. Realizar el análisis.',
          'Paso 4. Establecer consideraciones e hipótesis.',
          'Paso 3. Determinar los diagramas y datos.',
          'Paso 2. Determinar lo que se debe hallar.',
          'Paso 1. Determinar lo conocido.'
        ],
        right: ['1', '2', '3', '4', '5'],
        correct: [4, 3, 2, 1, 0],
        explanation: 'Secuencia lógica del método propuesto.'
      },
      {
        id: 12,
        type: 'multi',
        prompt: 'Ejemplos de restricción en diseño y análisis:',
        options: ['Estándares de seguridad', 'Estética final', 'Estándares ambientales', 'Costos'],
        correct: [0, 2, 3],
        explanation: 'Seguridad, ambiente y costos suelen figurar como restricciones; la estética es criterio pero no siempre una restricción dura.'
      },
      {
        id: 13,
        type: 'tf',
        prompt: 'Un flujo unidimensional es un flujo de materia que entra o sale de un volumen de control.',
        correct: false,
        explanation: '1D describe variación principal en una sola dirección; lo otro describe un sistema abierto.'
      },
      {
        id: 14,
        type: 'single',
        prompt: '¿En qué componente la velocidad del fluido disminuye en la dirección del flujo?',
        options: ['Difusor', 'Compresor', 'Intercambiador de calor', 'Bomba', 'Tobera'],
        correct: 0,
        explanation: 'El difusor ensancha el área y reduce la velocidad aumentando la presión.'
      },
      {
        id: 15,
        type: 'tf',
        prompt: 'Una turbomáquina donde "se produce calor" al pasar un fluido por álabes solidarios a un eje.',
        correct: false,
        explanation: 'La función principal es intercambio de trabajo, no producir calor como único efecto.'
      },
      {
        id: 16,
        type: 'tf',
        prompt: 'Las variaciones de energía cinética y potencial suelen ser muy pequeñas y pueden despreciarse.',
        correct: true,
        explanation: 'Es una aproximación común en balances de energía de equipos.'
      },
      {
        id: 17,
        type: 'multi',
        prompt: 'Ejemplos de compresores alternativos:',
        options: ['Centrífugos', 'Tipo Roots', 'De biela y pistón', 'De diafragma', 'De flujo axial'],
        correct: [2, 3],
        explanation: 'Biela-pistón y diafragma son alternativos; centrífugos/axiales son turbocompresores; Roots es de lóbulos rotativos.'
      },
      {
        id: 18,
        type: 'multi',
        prompt: 'En qué componentes se realiza trabajo para modificar el estado del fluido:',
        options: ['Bombas', 'Compresores', 'Difusores', 'Toberas', 'Turbinas'],
        correct: [0, 1],
        explanation: 'Bombas/compresores consumen trabajo; la turbina entrega trabajo al eje.'
      },
      {
        id: 19,
        type: 'tf',
        prompt: 'Los compresores aumentan la presión por transferencia de energía en forma de calor.',
        correct: false,
        explanation: 'El aumento de presión se logra por trabajo mecánico sobre el fluido.'
      },
      {
        id: 20,
        type: 'multi',
        prompt: 'Aplicaciones de intercambiadores de calor:',
        options: [
          'Cámara de combustión',
          'Condensador de heladera',
          'Bomba de central térmica',
          'Compresor de heladera',
          'Radiador de automóvil',
          'Evaporador de un generador de vapor',
          'Turbina de vapor'
        ],
        correct: [1, 4, 5],
        explanation: 'Condensadores, radiadores y generadores de vapor intercambian calor entre corrientes.'
      },
      {
        id: 21,
        type: 'match',
        prompt: 'Unir cada modo con su descripción.',
        left: [
          'Calor entre cuerpos en contacto a distinta T.',
          'Calor mediado por un fluido por efecto de campo de T y velocidades.',
          'Calor por emisión/absorción de radiación electromagnética.'
        ],
        right: ['Conducción', 'Convección', 'Radiación'],
        correct: [0, 1, 2],
        explanation: 'Definiciones estándar de conducción, convección y radiación.'
      },
      {
        id: 22,
        type: 'multi',
        prompt: 'Verdadero o falso (marca V para verdadero y F para falso).',
        subitems: [
          'Si un fluido es incompresible, cv = cp.',
          'El calor específico es una propiedad extensiva.',
          'Calor específico: calor para elevar en más de una unidad de temperatura a 1 kg.'
        ],
        correct: [true, false, false],
        explanation: 'Para incompresible ideal cp≈cv; el calor específico es intensivo; la definición correcta refiere a "una unidad" de temperatura.'
      },
      {
        id: 23,
        type: 'single',
        prompt: 'En un intercambiador de placas, ¿cómo se intercambia energía entre fluidos?',
        options: ['Conducción y convección', 'Conducción y radiación', 'Convección y radiación', 'Solo convección', 'Conducción, convección y radiación', 'Solo radiación', 'Solo conducción'],
        correct: 0,
        explanation: 'Convección en cada lado y conducción a través de la placa.'
      },
      {
        id: 24,
        type: 'tf',
        prompt: 'En un intercambiador, solo puede desperdiciarse la variación de energía potencial.',
        correct: false,
        explanation: 'También hay pérdidas por fricción, térmicas, etc.'
      },
      // 25–44: repetidos/variantes del mismo banco (con las mismas respuestas):
      {
        id: 25,
        type: 'multi',
        prompt: 'Seleccionar cuáles son los modos de transferencia de energía en termodinámica:',
        options: ['Energía cinética', 'Trabajo', 'Energía interna', 'Entropía', 'Calor', 'Energía potencial'],
        correct: [1, 4],
        explanation: 'Solo trabajo y calor son modos de transferencia.'
      },
      {
        id: 26,
        type: 'multi',
        prompt: 'Seleccionar cuáles son los modos de transferencia de calor:',
        options: ['Convección', 'Radiación', 'Evaporación', 'Fusión', 'Conducción'],
        correct: [0, 1, 4],
        explanation: 'Conducción, convección y radiación.'
      },
      {
        id: 27,
        type: 'tf',
        prompt: 'Según el convenio de signos, Q > 0 hacia el sistema y Q < 0 desde el sistema.',
        correct: true,
        explanation: 'Convención clásica.'
      },
      {
        id: 28,
        type: 'single',
        prompt: 'Ciclos utilizados solo en motores de combustión externa:',
        options: ['Ciclo Diésel', 'Ciclo Otto', 'Ciclo Rankine', 'Ciclo Brayton'],
        correct: 2,
        explanation: 'Rankine típico = combustión externa.'
      },
      {
        id: 29,
        type: 'match',
        prompt: 'Emparejar principios y enunciados:',
        left: [
          'Intercambia trabajo y calor; acumula energía interna.',
          'Imposible transferir calor de frío a caliente como único efecto.',
          'Imposible convertir íntegramente el calor absorbido en trabajo en un ciclo.'
        ],
        right: [
          'Principio de conservación de la energía',
          'Formulación de Clausius',
          'Enunciado de Kelvin–Planck'
        ],
        correct: [0, 1, 2],
        explanation: '1ª Ley y dos enunciados de la 2ª Ley.'
      },
      {
        id: 30,
        type: 'multi',
        prompt: '¿Cuáles corresponden al 2º principio de la termodinámica?',
        options: [
          'Q fluye de T alta a T baja.',
          'Imposible transferir calor de frío a caliente como único efecto.',
          'Conservación de la energía en sistemas.',
          'Imposible convertir íntegramente el calor en trabajo en un ciclo.',
          'Un sistema puede intercambiar W y Q.'
        ],
        correct: [0, 1, 3],
        explanation: 'Direccionalidad del calor (a), Clausius (b) y Kelvin–Planck (d).'
      },
      {
        id: 31,
        type: 'tf',
        prompt: 'El enunciado de Kelvin–Planck es: "...transferir calor de un cuerpo frío a otro más caliente como único efecto".',
        correct: false,
        explanation: 'Ese enunciado corresponde a Clausius; Kelvin–Planck trata sobre convertir totalmente calor en trabajo.'
      },
      {
        id: 32,
        type: 'single',
        prompt: 'Clasificación de un motor de explosión de automóviles:',
        options: ['Combustión externa alternativa', 'Combustión externa rotativa', 'Combustión interna alternativa', 'Combustión interna rotativa'],
        correct: 2,
        explanation: 'Motor de encendido por chispa: combustión interna alternativa.'
      },
      {
        id: 33,
        type: 'match',
        prompt: 'Emparejar aplicación con clasificación (considerando configuraciones típicas):',
        left: [
          'Turbina de gas ciclo abierto',
          'Turbina de gas ciclo cerrado',
          'Motor de explosión',
          'Máquina de vapor (turbina)'
        ],
        right: [
          'Combustión interna rotativa',
          'Combustión externa rotativa',
          'Combustión interna alternativa',
          'Combustión externa alternativa'
        ],
        correct: [0, 1, 2, 1],
        explanation: 'Abierto: interna rotativa. Cerrado: calentamiento externo. Motor de explosión: interna alternativa. La máquina de vapor con turbina es externa rotativa.'
      },
      {
        id: 34,
        type: 'multi',
        prompt: 'Aplicaciones del ciclo Brayton:',
        options: ['Motor de combustión interna', 'Máquina de vapor', 'Turbina de avión', 'Turbina de vapor', 'Turbina de gas'],
        correct: [2, 4],
        explanation: 'Brayton rige turbinas de gas y turborreactores.'
      },
      {
        id: 35,
        type: 'single',
        prompt: '¿Qué ciclo puede lograr la máxima eficiencia reversible?',
        options: ['Otto', 'Diésel', 'Rankine', 'Brayton', 'Carnot'],
        correct: 4,
        explanation: 'Carnot fija el límite superior reversible.'
      },
      {
        id: 36,
        type: 'tf',
        prompt: 'Existen rendimientos más altos que el ciclo de Carnot.',
        correct: false,
        explanation: 'Ninguna máquina térmica reversible supera a Carnot entre las mismas T.'
      },
      {
        id: 37,
        type: 'single',
        prompt: 'Un ciclo de Carnot está compuesto por:',
        options: [
          'Dos procesos isotermos y dos adiabáticos',
          'Dos isocóricos y dos adiabáticos',
          'Dos isotermos y dos isobáricos',
          'Dos isocóricos y dos isotermos',
          'Dos isobáricos y dos adiabáticos'
        ],
        correct: 0,
        explanation: 'Isotermos + adiabáticos.'
      },
      {
        id: 38,
        type: 'tf',
        prompt: 'Un ciclo Ericsson reversible está formado por dos isocoras y dos isobaras.',
        correct: false,
        explanation: 'Ericsson ideal: compresión/expansión isotérmica y calentamiento/enfriamiento isobárico con regeneración.'
      },
      {
        id: 39,
        type: 'multi',
        prompt: 'Restricciones en diseño y análisis de ingeniería:',
        options: ['Costos', 'Estética final', 'Estándares de medio ambiente', 'Estándares de seguridad'],
        correct: [0, 2, 3],
        explanation: 'Costos, ambiente y seguridad suelen ser restricciones clave.'
      },
      {
        id: 40,
        type: 'tf',
        prompt: 'Un flujo unidimensional es un flujo de materia que entra o sale de un volumen de control.',
        correct: false,
        explanation: 'Eso describe un sistema abierto; 1D refiere a cómo varían las propiedades.'
      },
      {
        id: 41,
        type: 'single',
        prompt: '¿En qué componente disminuye la velocidad en la dirección del flujo?',
        options: ['Difusor', 'Bomba', 'Compresor', 'Tobera', 'Intercambiador de calor'],
        correct: 0,
        explanation: 'El difusor reduce velocidad y eleva presión.'
      },
      {
        id: 42,
        type: 'tf',
        prompt: 'Dispositivo donde "se produce calor" por el paso de un fluido por álabes solidarios a un eje.',
        correct: false,
        explanation: 'Las turbomáquinas intercambian trabajo principalmente.'
      },
      {
        id: 43,
        type: 'single',
        prompt: 'Intercambio de energía en un intercambiador de placas:',
        options: ['Solo Convección', 'Conducción, convección y radiación', 'Conducción y radiación', 'Convección y radiación', 'Solo conducción', 'Solo radiación', 'Conducción y convección'],
        correct: 6,
        explanation: 'Conducción a través de la placa y convección en los canales.'
      },
      {
        id: 44,
        type: 'tf',
        prompt: 'En un intercambiador, solo se puede desperdiciar la variación de energía potencial.',
        correct: false,
        explanation: 'Hay múltiples pérdidas mecánicas y térmicas además de la potencial.'
      }
    ];

    const questions = normalizeQuestions(QUESTIONS);

    const typeLabels = {
      single: 'Selección única',
      multi: 'Selección múltiple',
      tf: 'Verdadero / Falso',
      match: 'Emparejar',
      group_tf: 'Verdadero / Falso (múltiple)'
    };

    const storageKey = 'thermoEngineeringQuiz_v1';
    let state = loadState();
    const multiDelayTimers = new Map();

    const summaryContainer = document.getElementById('summaryButtons');
    const questionContent = document.getElementById('questionContent');
    const retryButton = document.getElementById('retryButton');
    const prevBtn = document.getElementById('prevBtn');
    const nextBtn = document.getElementById('nextBtn');
    const scoreCountEl = document.getElementById('scoreCount');
    const scorePercentageEl = document.getElementById('scorePercentage');
    const scoreBadgeEl = document.getElementById('scoreBadge');

    prevBtn.addEventListener('click', () => {
      goToQuestion(state.currentIndex - 1);
    });

    nextBtn.addEventListener('click', () => {
      if (state.currentIndex >= questions.length - 1) {
        document.getElementById('resultsCard').scrollIntoView({ behavior: 'smooth', block: 'center' });
        return;
      }
      goToQuestion(state.currentIndex + 1);
    });

    retryButton.addEventListener('click', () => {
      const question = questions[state.currentIndex];
      clearMultiTimer(question.id);
      delete state.answers[question.id];
      delete state.evaluations[question.id];
      saveState();
      renderQuestion();
      renderSummary();
      updateResults();
    });

    function normalizeQuestions(rawQuestions) {
      return rawQuestions.map((raw, index) => {
        const baseId = typeof raw.id === 'number' || typeof raw.id === 'string' ? raw.id : index + 1;
        const questionId = `q${baseId}`;
        const base = {
          id: questionId,
          type: raw.type,
          prompt: raw.prompt ?? raw.title ?? '',
          explanation: raw.explanation ?? '',
          helper: raw.helper ?? null
        };

        switch (raw.type) {
          case 'single': {
            const options = createOptionObjects(raw.options);
            const correctIndex = Array.isArray(raw.correct) ? raw.correct[0] : raw.correct;
            return {
              ...base,
              type: 'single',
              options,
              correct: toStringIndex(correctIndex)
            };
          }
          case 'multi': {
            if (Array.isArray(raw.subitems)) {
              const statements = raw.subitems.map((text, idx) => ({
                id: `${questionId}-s${idx}`,
                text,
                correct: Array.isArray(raw.correct) ? Boolean(raw.correct[idx]) : Boolean(raw.correct)
              }));
              return {
                ...base,
                type: 'group_tf',
                statements
              };
            }
            const options = createOptionObjects(raw.options);
            const correctValues = Array.isArray(raw.correct)
              ? raw.correct.map(value => toStringIndex(value)).filter(value => value !== '')
              : [];
            return {
              ...base,
              type: 'multi',
              options,
              correct: correctValues
            };
          }
          case 'tf': {
            return {
              ...base,
              type: 'tf',
              options: [
                { value: 'true', label: 'Verdadero' },
                { value: 'false', label: 'Falso' }
              ],
              correct: raw.correct ? 'true' : 'false'
            };
          }
          case 'match': {
            return {
              ...base,
              type: 'match',
              pairs: normalizeMatchPairs(raw)
            };
          }
          default: {
            const options = createOptionObjects(raw.options);
            const correct = Array.isArray(raw.correct)
              ? raw.correct.map(value => toStringIndex(value)).filter(value => value !== '')
              : toStringIndex(raw.correct);
            return {
              ...base,
              options,
              correct
            };
          }
        }
      });
    }

    function createOptionObjects(optionList) {
      if (!Array.isArray(optionList)) {
        return [];
      }
      return optionList.map((label, idx) => ({
        value: toStringIndex(idx),
        label
      }));
    }

    function normalizeMatchPairs(raw) {
      const rightOptions = Array.isArray(raw.right)
        ? raw.right.map((label, idx) => ({ value: toStringIndex(idx), label }))
        : [];
      const correctIndexes = Array.isArray(raw.correct) ? raw.correct : [];
      return Array.isArray(raw.left)
        ? raw.left.map((leftText, idx) => ({
            left: leftText,
            options: rightOptions.map(option => ({ ...option })),
            correct: toStringIndex(correctIndexes[idx])
          }))
        : [];
    }

    function toStringIndex(value) {
      if (value === null || value === undefined) {
        return '';
      }
      return String(value);
    }

    init();

    function init() {
      renderSummary();
      renderQuestion();
      updateResults();
    }

    function loadState() {
      const defaultState = {
        currentIndex: 0,
        answers: {},
        evaluations: {}
      };

      try {
        const stored = localStorage.getItem(storageKey);
        if (!stored) {
          return defaultState;
        }
        const parsed = JSON.parse(stored);
        return {
          currentIndex: clampIndex(parsed.currentIndex ?? 0),
          answers: parsed.answers ?? {},
          evaluations: parsed.evaluations ?? {}
        };
      } catch (error) {
        console.warn('No se pudo recuperar el estado guardado:', error);
        return defaultState;
      }
    }

    function saveState() {
      try {
        localStorage.setItem(storageKey, JSON.stringify(state));
      } catch (error) {
        console.warn('No se pudo guardar el progreso:', error);
      }
    }

    function clampIndex(index) {
      if (typeof index !== 'number' || Number.isNaN(index)) {
        return 0;
      }
      return Math.min(Math.max(index, 0), questions.length - 1);
    }

    function goToQuestion(index) {
      state.currentIndex = clampIndex(index);
      saveState();
      renderQuestion();
      renderSummary();
    }

    function renderSummary() {
      summaryContainer.innerHTML = '';
      questions.forEach((question, idx) => {
        const button = document.createElement('button');
        button.type = 'button';
        button.className = 'summary-btn';
        button.textContent = idx + 1;
        const evaluation = state.evaluations[question.id];
        if (evaluation?.isCorrect) {
          button.classList.add('is-correct');
        } else if (evaluation && !evaluation.isCorrect) {
          button.classList.add('is-incorrect');
        }
        if (state.currentIndex === idx) {
          button.classList.add('is-active');
        }
        button.setAttribute('aria-label', `Ir a la pregunta ${idx + 1}`);
        button.addEventListener('click', () => {
          goToQuestion(idx);
        });
        summaryContainer.appendChild(button);
      });
    }

    function renderQuestion() {
      clearMultiTimer(questions[state.currentIndex]?.id);
      const question = questions[state.currentIndex];
      if (!question) return;

      questionContent.innerHTML = '';
      const titleId = `${question.id}-title`;
      const evaluation = state.evaluations[question.id];
      const storedAnswer = state.answers[question.id];
      const isLocked = Boolean(evaluation);

      const promptText = question.prompt ?? question.title ?? '';
      const helperText = question.helper ?? '';
      const helperId = helperText ? `${question.id}-helper` : undefined;

      const header = document.createElement('div');
      header.className = 'question-header';
      header.innerHTML = `
        <div class="question-meta">
          <span class="chip">${typeLabels[question.type] ?? 'Pregunta'}</span>
          <span class="counter">Pregunta ${state.currentIndex + 1} de ${questions.length}</span>
        </div>
        <h2 class="question-title" id="${titleId}">${promptText}</h2>
        ${helperText ? `<p class="question-helper" id="${helperId}">${helperText}</p>` : ''}
      `;
      questionContent.appendChild(header);

      const optionsWrapper = document.createElement('div');
      optionsWrapper.className = 'options-wrapper';
      const role = question.type === 'single' || question.type === 'tf' ? 'radiogroup' : 'group';
      optionsWrapper.setAttribute('role', role);
      optionsWrapper.setAttribute('aria-labelledby', titleId);
      if (helperId) {
        optionsWrapper.setAttribute('aria-describedby', helperId);
      }
      questionContent.appendChild(optionsWrapper);

      if (question.type === 'match') {
        question.pairs.forEach(pair => {
          const row = document.createElement('div');
          row.className = 'match-row';
          row.dataset.left = pair.left;

          const label = document.createElement('span');
          label.className = 'match-term';
          label.textContent = pair.left;

          const select = document.createElement('select');
          select.dataset.left = pair.left;
          const placeholderOption = document.createElement('option');
          placeholderOption.value = '';
          placeholderOption.textContent = 'Seleccioná una opción';
          select.appendChild(placeholderOption);

          pair.options.forEach(option => {
            const optEl = document.createElement('option');
            optEl.value = option.value;
            optEl.textContent = option.label;
            select.appendChild(optEl);
          });

          if (storedAnswer && storedAnswer[pair.left]) {
            select.value = storedAnswer[pair.left];
          }
          if (isLocked) {
            select.disabled = true;
          }

          const helper = document.createElement('span');
          helper.className = 'match-answer';
          helper.setAttribute('aria-hidden', 'true');

          row.append(label, select, helper);
          optionsWrapper.appendChild(row);

          if (!isLocked) {
            select.addEventListener('change', () => {
              const answer = collectMatchAnswer();
              if (!answer) {
                return;
              }
              applyEvaluation(question, answer);
            });
          }
        });
      } else if (question.type === 'group_tf') {
        question.statements.forEach((statement, idx) => {
          const row = document.createElement('div');
          row.className = 'match-row group-tf-row';
          row.dataset.index = String(idx);
          row.dataset.question = question.id;

          const term = document.createElement('span');
          term.className = 'match-term';
          term.textContent = statement.text;

          const controls = document.createElement('div');
          controls.className = 'group-tf-controls';

          ['true', 'false'].forEach(value => {
            const optionLabel = document.createElement('label');
            optionLabel.className = 'group-tf-option';

            const input = document.createElement('input');
            input.type = 'radio';
            input.name = `${question.id}-${idx}`;
            input.value = value;

            if (Array.isArray(storedAnswer) && storedAnswer[idx] === value) {
              input.checked = true;
            }
            if (isLocked) {
              input.disabled = true;
            }

            const text = document.createElement('span');
            text.textContent = value === 'true' ? 'Verdadero (V)' : 'Falso (F)';

            optionLabel.append(input, text);
            controls.appendChild(optionLabel);

            if (!isLocked) {
              input.addEventListener('change', () => {
                updateGroupTfOptionState(controls);
                const answer = collectGroupTfAnswer(question);
                if (!answer) {
                  return;
                }
                applyEvaluation(question, answer);
              });
            }
          });

          const helper = document.createElement('span');
          helper.className = 'match-answer';
          helper.setAttribute('aria-hidden', 'true');

          row.append(term, controls, helper);
          optionsWrapper.appendChild(row);

          updateGroupTfOptionState(controls);

          if (isLocked) {
            row.classList.add('is-locked');
          }
        });
      } else {
        const isMulti = question.type === 'multi';
        question.options.forEach(option => {
          const label = document.createElement('label');
          label.className = 'option-card option-card--' + question.type;
          label.dataset.value = option.value;

          const input = document.createElement('input');
          input.type = isMulti ? 'checkbox' : 'radio';
          input.name = question.id;
          input.value = option.value;
          if (isMulti && Array.isArray(storedAnswer) && storedAnswer.includes(option.value)) {
            input.checked = true;
          }
          if (!isMulti && storedAnswer === option.value) {
            input.checked = true;
          }
          if (isLocked) {
            input.disabled = true;
            label.classList.add('is-locked');
          }

          const indicator = document.createElement('span');
          indicator.className = 'option-indicator';

          const textWrapper = document.createElement('span');
          textWrapper.className = 'option-text';
          const mainText = document.createElement('span');
          mainText.className = 'option-main';
          mainText.textContent = option.label;
          textWrapper.appendChild(mainText);

          label.append(input, indicator, textWrapper);
          optionsWrapper.appendChild(label);

          if (!isLocked) {
            if (isMulti) {
              input.addEventListener('change', () => {
                const selectedValues = collectMultiAnswer(question.id);
                if (!selectedValues || selectedValues.length === 0) {
                  clearMultiTimer(question.id);
                  return;
                }
                clearMultiTimer(question.id);
                const timer = setTimeout(() => {
                  applyEvaluation(question, selectedValues);
                }, 900);
                multiDelayTimers.set(question.id, timer);
              });
            } else {
              input.addEventListener('change', () => {
                applyEvaluation(question, option.value);
              });
            }
          }
        });
      }

      const feedback = document.createElement('div');
      feedback.className = 'feedback-area';
      feedback.innerHTML = `
        <p class="feedback-message" id="feedbackMessage" role="status" aria-live="polite"></p>
        <p class="correct-answer" id="correctAnswer"></p>
        <p class="explanation-text" id="explanationText"></p>
      `;
      questionContent.appendChild(feedback);

      if (evaluation && storedAnswer !== undefined) {
        showCorrection(question, evaluation, storedAnswer);
        updateFeedbackUI(question, evaluation);
      } else {
        updateFeedbackUI(question, null);
      }

      toggleRetryButton(isLocked);
      updateNavigation();
    }

    function applyEvaluation(question, rawAnswer) {
      const storedAnswer = cloneAnswer(question, rawAnswer);
      const evaluation = evaluateQuestion(question, storedAnswer);

      state.answers[question.id] = storedAnswer;
      state.evaluations[question.id] = evaluation;
      saveState();
      clearMultiTimer(question.id);

      showCorrection(question, evaluation, storedAnswer);
      updateFeedbackUI(question, evaluation);
      toggleRetryButton(true);
      renderSummary();
      updateResults();
    }

    function cloneAnswer(question, answer) {
      if (question.type === 'multi') {
        return Array.isArray(answer) ? [...answer] : [];
      }
      if (question.type === 'group_tf') {
        return Array.isArray(answer) ? [...answer] : [];
      }
      if (question.type === 'match') {
        return answer ? { ...answer } : {};
      }
      return typeof answer === 'string' ? answer : null;
    }

    function evaluateQuestion(question, userAnswer) {
      let isCorrect = false;
      let correctAnswers;

      switch (question.type) {
        case 'single':
        case 'tf': {
          const correctValue = Array.isArray(question.correct) ? question.correct[0] : question.correct;
          isCorrect = userAnswer === correctValue;
          correctAnswers = Array.isArray(question.correct) ? [...question.correct] : [question.correct];
          break;
        }
        case 'multi': {
          const expected = Array.isArray(question.correct) ? [...question.correct].sort() : [];
          const received = Array.isArray(userAnswer) ? [...userAnswer].sort() : [];
          isCorrect = expected.length === received.length && expected.every((value, idx) => value === received[idx]);
          correctAnswers = expected;
          break;
        }
        case 'group_tf': {
          const expected = Array.isArray(question.statements)
            ? question.statements.map(item => Boolean(item.correct))
            : [];
          const received = Array.isArray(userAnswer)
            ? expected.map((_, idx) => userAnswer[idx] === 'true')
            : [];
          isCorrect = expected.length === received.length && expected.every((value, idx) => received[idx] === value);
          correctAnswers = expected;
          break;
        }
        case 'match': {
          correctAnswers = question.pairs.map(pair => ({ left: pair.left, value: pair.correct }));
          const provided = userAnswer || {};
          isCorrect = question.pairs.every(pair => provided[pair.left] === pair.correct);
          break;
        }
        default:
          correctAnswers = [];
      }

      return {
        isCorrect,
        correctAnswers,
        explanation: question.explanation
      };
    }

    function showCorrection(question, evaluation, userAnswer) {
      const correctAnswers = evaluation.correctAnswers;
      if (question.type === 'match') {
        const rows = questionContent.querySelectorAll('.match-row');
        rows.forEach(row => {
          const key = row.dataset.left;
          const select = row.querySelector('select');
          const helper = row.querySelector('.match-answer');
          const expected = correctAnswers.find(item => item.left === key);
          if (select) {
            select.disabled = true;
          }
          if (helper && expected) {
            helper.textContent = `Correcta: ${getMatchLabel(question, key, expected.value)}`;
            row.classList.add('show-answer');
          }
          if (userAnswer && userAnswer[key] === expected?.value) {
            row.classList.add('is-correct');
          } else {
            row.classList.add('is-incorrect');
          }
        });
      } else if (question.type === 'group_tf') {
        const rows = questionContent.querySelectorAll('.group-tf-row');
        rows.forEach(row => {
          const index = Number(row.dataset.index ?? -1);
          const helper = row.querySelector('.match-answer');
          const controls = row.querySelector('.group-tf-controls');
          const expectedValue = correctAnswers[index] ? 'true' : 'false';
          const selectedValue = Array.isArray(userAnswer) ? userAnswer[index] : undefined;

          row.classList.add('show-answer', 'is-locked');

          row.querySelectorAll('input').forEach(input => {
            input.disabled = true;
          });

          if (controls) {
            updateGroupTfOptionState(controls);
          }

          if (helper && correctAnswers[index] !== undefined) {
            helper.textContent = `Correcta: ${correctAnswers[index] ? 'Verdadero' : 'Falso'}`;
          }

          const expectedOption = row.querySelector(`.group-tf-option input[value="${expectedValue}"]`);
          if (expectedOption?.parentElement) {
            expectedOption.parentElement.classList.remove('is-active');
            expectedOption.parentElement.classList.add('show-correct', 'is-correct');
          }

          if (selectedValue) {
            const selectedOption = row.querySelector(`.group-tf-option input[value="${selectedValue}"]`);
            if (selectedOption?.parentElement) {
              selectedOption.parentElement.classList.remove('is-active');
              if (selectedValue === expectedValue) {
                selectedOption.parentElement.classList.add('is-correct');
              } else {
                selectedOption.parentElement.classList.add('is-incorrect');
              }
            }
          }

          if (selectedValue === expectedValue) {
            row.classList.add('is-correct');
          } else {
            row.classList.add('is-incorrect');
          }
        });
      } else {
        const selectedValues = Array.isArray(userAnswer) ? userAnswer : userAnswer ? [userAnswer] : [];
        const cards = questionContent.querySelectorAll('.option-card');
        cards.forEach(card => {
          const value = card.dataset.value;
          const input = card.querySelector('input');
          if (input) {
            input.disabled = true;
          }
          card.classList.add('is-locked');
          if (selectedValues.includes(value)) {
            card.classList.add(correctAnswers.includes(value) ? 'is-correct' : 'is-incorrect');
          }
          if (correctAnswers.includes(value)) {
            card.classList.add('show-correct');
          }
        });
      }
    }

    function updateFeedbackUI(question, evaluation) {
      const feedbackMessage = document.getElementById('feedbackMessage');
      const correctAnswerEl = document.getElementById('correctAnswer');
      const explanationEl = document.getElementById('explanationText');
      if (!feedbackMessage || !correctAnswerEl || !explanationEl) return;

      if (!evaluation) {
        feedbackMessage.textContent = 'Seleccioná una respuesta para ver si es correcta.';
        feedbackMessage.className = 'feedback-message';
        correctAnswerEl.textContent = '';
        explanationEl.textContent = '';
        return;
      }

      feedbackMessage.textContent = evaluation.isCorrect ? '¡Correcto!' : 'Respuesta incorrecta';
      feedbackMessage.className = 'feedback-message ' + (evaluation.isCorrect ? 'success' : 'error');
      correctAnswerEl.textContent = 'Respuesta correcta: ' + formatCorrectAnswer(question, evaluation);
      explanationEl.textContent = evaluation.explanation;
    }

    function toggleRetryButton(show) {
      if (show) {
        retryButton.hidden = false;
        retryButton.disabled = false;
      } else {
        retryButton.hidden = true;
        retryButton.disabled = true;
      }
    }

    function updateNavigation() {
      prevBtn.disabled = state.currentIndex === 0;
      nextBtn.textContent = state.currentIndex === questions.length - 1 ? 'Ver resultados' : 'Siguiente';
    }

    function updateResults() {
      const evaluations = Object.values(state.evaluations);
      const correctCount = evaluations.filter(entry => entry?.isCorrect).length;
      const total = questions.length;
      const percentage = total === 0 ? 0 : Math.round((correctCount / total) * 100);

      scoreCountEl.textContent = `${correctCount} / ${total}`;
      scorePercentageEl.textContent = `${percentage}%`;
      scoreBadgeEl.textContent = getBadgeLabel(percentage);
    }

    function getBadgeLabel(percentage) {
      if (percentage >= 90) return 'Excelente';
      if (percentage >= 75) return 'Muy bien';
      return 'A seguir';
    }

    function formatCorrectAnswer(question, evaluation) {
      if (question.type === 'match') {
        return evaluation.correctAnswers
          .map(item => `${item.left} → ${getMatchLabel(question, item.left, item.value)}`)
          .join('; ');
      }
      if (question.type === 'group_tf') {
        const statements = Array.isArray(question.statements) ? question.statements : [];
        return statements
          .map((statement, idx) => {
            const expected = evaluation.correctAnswers?.[idx];
            const label = expected ? 'Verdadero' : 'Falso';
            return `${statement.text ?? `Enunciado ${idx + 1}`} → ${label}`;
          })
          .join('; ');
      }
      const optionMap = new Map();
      if (Array.isArray(question.options)) {
        question.options.forEach(option => {
          optionMap.set(option.value, option.label);
        });
      }
      return evaluation.correctAnswers
        .map(value => optionMap.get(value) ?? value)
        .join(', ');
    }

    function getMatchLabel(question, left, value) {
      const pair = question.pairs.find(item => item.left === left);
      if (!pair) return value;
      const option = pair.options.find(opt => opt.value === value);
      return option ? option.label : value;
    }

    function collectGroupTfAnswer(question) {
      if (!question) {
        return null;
      }
      const rows = questionContent.querySelectorAll(`.group-tf-row[data-question="${question.id}"]`);
      const answer = [];
      let filled = true;
      rows.forEach(row => {
        const index = Number(row.dataset.index ?? -1);
        const checked = row.querySelector('input:checked');
        if (!checked) {
          filled = false;
          return;
        }
        answer[index] = checked.value;
      });
      return filled ? answer : null;
    }

    function updateGroupTfOptionState(container) {
      if (!container) return;
      container.querySelectorAll('.group-tf-option').forEach(option => {
        const input = option.querySelector('input');
        option.classList.toggle('is-active', Boolean(input?.checked));
      });
    }

    function collectMultiAnswer(questionId) {
      return Array.from(document.querySelectorAll(`input[name="${questionId}"]:checked`)).map(input => input.value);
    }

    function collectMatchAnswer() {
      const rows = questionContent.querySelectorAll('.match-row');
      const answer = {};
      let filled = true;
      rows.forEach(row => {
        const select = row.querySelector('select');
        const key = select?.dataset.left;
        if (!key) return;
        if (!select.value) {
          filled = false;
        }
        answer[key] = select.value || null;
      });
      return filled ? answer : null;
    }

    function clearMultiTimer(questionId) {
      if (!questionId) return;
      if (multiDelayTimers.has(questionId)) {
        clearTimeout(multiDelayTimers.get(questionId));
        multiDelayTimers.delete(questionId);
      }
    }
  </script>
</body>
</html>
